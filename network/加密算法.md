
## 一 对称性加密

1. 两个相同的比特序列做异或的结果为0，一个非零数和0做异或的结果是它本身。

2. 一种简单的加密方式（利用异或运算）

我们可以生成一个长度和原始信息一样的随机比特序列作为密钥，然后用它对原始信息做异或运算，就生成了密文。反之，再用该密钥对密文做一次异或运算，就可以解密得到原始信息。

3. 对称加密的关键在于如何让解决密钥配送的问题。

## 二 密钥交换算法

Diffie-Hellman 密钥交换算法可以做到通过一些共享数字，双方“心中”各自“生成”了一个相同的秘密，而且双方的这个秘密，是第三方窃听者无法生成的。

这一算法利用了某些数学运算的不可逆的性质，进行密钥传输，因此第三方无法反推得到密钥。

然而这种加密方式也是存在漏洞的， hack可以不窃听客户端与服务器的通信数据，而是同时冒充客户端和服务器的身份，也就是我们说的「中间人攻击」。 密钥交换算法虽然解决了密钥配送问题，但是无法核实对方身份，所以我们需要引入数字签名来核实对方身份。

## 三 非对称加密

1. 非对称加密就是把公钥发给对方，对方用公钥加密数据，双方用公钥加密发送数据，然后用各自的私钥解密数据。公钥是锁，私钥是🔑。

2. 非对称加密的运算速度要比对称加密慢很多，所以传输大量数据时，一般不会用公钥直接加密数据，而是加密对称性加密的密钥，传输给对方，然后双方使用对称性加密算法传输数据。

3. 非对称加密算法，也无法确定通信双方的身份，依然会遭到中间人攻击。比如hack拦截bob发出的公钥，然后冒充bob的身份给alice发送自己的公钥，那么不知情的alice就会把私密数据用hack的公钥加密，hack可以通过私钥解密窃取。

## 四 数字签名

1. 数字签名也是利用了非对称加密的特性，但是和公钥加密不同，仍然公布公钥，但是用你的私钥加密数据，然后把加密的数据公布出去，这就是数字签名。具体流程如下：

* bob生成公钥和私钥，然后把公钥公布出去，私钥自己保留。
* 用私钥加密数据作为签名，然后将数据附带签名一同发布出去。
* alice收到数据和签名，需要检查此份数据是否是bob所发出，于是用bob之前发出的公钥尝试解密签名，将收到的数据和签名解密后的结果做对比，如果完全相同，则说明数据没被篡改，确实由bob发出。


2. 为什么这种方式能唯一确定bob的身份呢？

* 如果有人修改了数据，那么alice解密签名之后，对比发现二者不一致，察觉出异常
* 如果有人替换来签名，alice用bob的公钥只能解出一串乱码，显然和数据不一致
* 如果有人修改数据没然后将修改之后的数据再签名，alice则无法通过对比数据发现不一致，但是一旦揭开签名，就不可能再重新生成bob的签名了，因为没有bob的密钥。

事实上，这种方式依然存在中间人攻击的问题，中间人劫持，发送自己的假公钥和自己签名，依然可以与alice和bob进行数据通信。想要确定对方的身份，必须有一个信任的源头，否则的话，再多的流程也只是在转移问题，而不是真正解决问题。

## 五 公钥证书

证书其实就是公钥+签名，由第三方认证机构办法。

证书认证的流程大致如下：

* bob去可信任的认证机构证实本人的真实身份，并提供自己的公钥
* alice想跟bob通信，首先向认证机构请求bob的公钥，认证机构会把一张证书（bob的公钥以及机构对其公钥的签名）发送给alice。
* alice检查签名，确定公钥确实由这家认证机构发送，中途未被篡改。
* alice通过这个公钥加密数据，开始和bob通信。

https协议中的ssl/tls 安全层组合使用以上集中加密方式，所以不要安装非正规的浏览器，里面可能有未知来源的证书。




