# javascript-pattern
设计模式与开发实践读书笔记.

> 设计模式的定义
> 设计模式的定义是:在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案.

> 从某些角度看,设计模式确实有可能带来代码量的增加,或许会把系统的逻辑搞得更复杂,但是软件开发的成本并非全部在开发阶段,设计模式的作用是让人们写出可复用和可维护性高的程序.

> 锤子理论: 当我们有了一把锤子,看什么都是钉子.模式存在的目的是为了帮助我们解决一些问题,不应为了模式而模式

##第一部分 基础知识

### 1. 面向对象的javascript

#### 1.1 动态类型语言和鸭子类型

编程语言的分类

**编程语言按照数据类型大体分为两类,一类是静态类型语言,另一类是动态类型语言.静态类型语言实在编译时候已确定为变量的类型.而动态类型语言的变量类型要到程序运行的时候,待变量被赋予某个值之后,才会具有某种类型.**

静态类型语言的优缺点

**优点: 1. 在编译时就能发现类型不匹配的错误,编辑器可以帮助我们避免程序运行期间可能出现的错误 2. 编译器可根据确定了数据类型的数据信息进行相应优化,提高程序执行速度.**

**缺点: 1. 使程序员的编程受数据类型显示  2.增加更多的代码,分散程序员的精力**

动态类型语言的优缺点

**优点: 1.更加清晰简洁的代码,使得程序员可以更多滴光柱业务逻辑.  2.没有了类型检测,使得程序的编写变得更为灵活.**

**缺点: 1. 无法保证变量的类型,从而在程序的运行期间可能会发生和类型相关的错误.**

鸭子类型的概念

如果一个动物的一个我们期望的行为和鸭子一致,那不管这个动物是不是鸭子,都可以认为它是鸭子.

#### 1.2 多态

**多态的实际含义是:统一操作作用于不同的对象上面,可以产生不同的解释和不同的执行结果,换句话说,给不同的对象发送同一个消息的时候,这些对象会根据这消息给出不同的反馈**

>多态的根本好处在于,你不必要再向对象询问"你是什么类型"而后根据得到的答案调用对象的某个行为,你只管调用行为就是了,其他的一切多态都会为你安排妥当.换句话说,多态最根本的作用就是把过程化的条件分支语句转化为对象的多态性,从而消除这些条件分支语句.

将行为分布在各个对象中,并让这些对象各自负责自己的行为.我们只需要关注做什么,而怎么做是每个对象自己负责管理,JavaScript的多态性是与生俱来的.多态最根本的作用就是把过程化的条件分支语句转换成对象的多态性,从而消除这些分支语句.

### 1.4 原型模式和基于原型继承的Javascript对象系统

原型模式: 原型模式是指我们在创建一个对象时,不再关心对象的具体类型,而是找到一个对象,然后通过克隆赖=来创建一个一模一样的对象.当需要创建有多个具有相同功能的对象(也即某个类型的对象),我们就可以采用原型模式,JavaScript提供了Object.create()方法来克隆对象.

基于原型链的委托机制就是原型继承的本质.
原型编程中的一个重要特性,即当对象无法响应某个请求时,会将该请求委托给它的构造器的原型对象

对象的_proto_ 属性默认会指向他的构造器的原型对象{Constructor}.prototype,所以对想通过_proto_ 属性记住它的原型
Object.prototype对象是一个空对象,它的原型是null,除了Object.prototype本身之外,任何对象都是有原型的,而通过Object.create(null)可以创建出没有原型的对象

JavaScript的函数既可以作为普通函数被调用,也可以作为构造函数被调用,当时用new运算符来调用函数时,此时的函数就是一个构造器,使用new运算符来创建对象的过程,实际上也只是先克隆Object.prototype对象,在进行其他一些额外操作的过程.


### 2. this, call, apply

#### 2.1 this
this总是指向函数运行时所在的对象
this的指向呆滞可以分为以下4种:
* 作为对象的方法调用  //此时调用时候的this指向该对象
* 作为普通函数调用    //此时调用时候的this指向window
* 构造器调用
* Function.prototype.call或Function.prototype.apply调用   //此时调用时候的this指向传入的第一个参数,如果第一个参数为空.则指向window

ES5严格模式下的Function.prototype.apply(null, [1,2,3]),函数运行时候的this是null,非严格模式下指向window
大部分浏览器实现了内置的Function.prototype.bind来指定函数内部的this指向
使用Array.prototype.push.call()方法传入的对象需要满足
1.对象本身要可以存取属性;  2.对象的length属性要可读写.  
除此之外,传入参数是string类型,number类型和fun类型都会报错.


### 3. 闭包和高阶函数

### 3.1.1 闭包
* 变量的作用域: 全局变量的作用域是全局,局部变量的作用域是定义它的函数的内部,也称为函数作用域.使用let函数命名的变量只在其生命的块或子块中可用,也称为块级作用域
* 变量的生存周期: 全局变量和的生存周期是永久的,除非我们主动销毁这个全局变量.局部变量会随着函数调用的结束而销毁.
* 内存回收的方法,将变量设置为null即可.


闭包的其中两个作用:
(1)封装变量
>> 我的想法: 我们应该把仅会在某个或某些函数内使用的变量定义在函数内部,这样既可以防止对全局变量的污染,又可以避免这个变量在其他地方被不小心修改而引发错误,将需要用到这个变量的函数写到定义着变量的函数内部,这样就形成了一个闭包.这就起到了封装变量的作用.
(2)延续局部变量的寿命
普通的局部变量在函数调用结束后会被销毁,然而如果我们在函数内部的函数里面用到了这个变量,便不会导致这个变量在函数调用之后被销毁,好像延长了变量的寿命一样.

>>我对于闭包的定义: 含有局部变量,使得这局部变量有了一个封闭的作用域,只在此函数内不可以访问到,外部无法访问到,我们就称这样的结构就是一个闭包.

### 3.1.2 用闭包实现命令模式
(1) 对象以方法的形式包含了过程,而闭包则是在过程中以环境的形式包含了数据.
>>命令模式的意图就是把请求封装成对象,从而分离请求的发起者和请求的接受者之间的耦合关系

### 3.2 高阶函数
特性:
(1)函数可以作为参数被传递
(2)函数的执行结果返回另外一个函数

函数作为参数传递的使用场景:
* 当我们想在ajax请求之后做一些事情,但又不知道请求返回的确切时间,最常见的方案就是把callback函数作为参数传入ajax请求中,带请求完成之后执行回调函数.

    var getUserInfo = function (userId, callback) {
        $.ajax('http:xxx.com/getUserInfo' + userId, function (data) {
            callback(data);
        });
    }

    getUserInfo(1334855, function (data) {
        alert(data.userName);
    });

* 我们可以把重复被调用的函数封装起来,作为一个参数传入这些调用它们的函数里
* 有时候编写一个功能函数的时候,为了避免这个函数太个性化,复用性太低,我们会把比较特有的逻辑处理代码放到回调函数里面,在需要这些特速处理的地方调用的时候传入回调函数即可.
* Array.prototype.sort和Array.prototype.map函数接受一个函数作为参数,这个函数可以对数组成员进行相应处理并返回.

函数作为返回值输出的使用场景:


>> 看到一个精辟又有意思的说法,vue不过是一个挂在在全局下的一个经过实例化的对象而已.
**高阶函数实现AOP**
AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来,如日志统计\安全控制,异常处理等.这样做的好处首先是可以保证业务逻辑模块的纯净和高内聚性,其次可以很方便的复用日志模块等功能.

**函数节流的原理就是降低函数被调用的频率**
**实现函数节流的两个典型方法: (1) 分式函数: 将批量操作分时进行,每次完成一部分 (2) 惰性加载函数: 在含有多个分支判断的地方重写该函数,避免每次进入函数都要进行的不必要的分支判断.**

>> 对于模式的实现过程,我们更关注的是模式能帮助我们完成什么

## 第二部分 设计模式

### 4. 单例模式

#### 4.1 概念
实现一个标准的单例模式,就是用一个变量来标志当前是否已经为某个类创建过对象如果是,则在下一次获取该类的实例时,直接返回之前创建的对象.

#### 4.2 惰性单例
惰性单例指的是在需要的时候才创建的实例对象,惰性单例是单例模式的重点.
正确的惰性单例的实现需要将创建对象和管理单例的职责分布在两个不同的方法中.

### 5. 策略模式

**策略模式的定义是: 定义一系列的算法,把他们各自封装成策略类.算法被封装在策略类内部的方法中,在客户对Context发起请求的时候,Context总是把请求委托给这些对象中的某一个进行计算.**
#### 5.1 
>> 不同的算法或者行为被封装在各个策略类中,Context将请求委托给这些策略对象,这些策略会根据请求返回不同的策略对象,这样便能表现出对象的多态性.
#### 5.2 策略模式的三个使用场景

(1) 计算奖金
(2) 缓动动画
(3) 表单校验

#### 5.3 策略模式的优缺点

(1) 策略模式利用组合,委托和多态等技术和思想,可以有效避免多重条件选择语句
(2) 策略模式提供了对开放-封闭原则的完美支持,将算法封装在独立的strategy中,使他们易于切换,易于理解,易于扩展.
(3) 策略模式的中的算法可以复用在系统的其他地方,从而避免了很多重复的复制粘贴工作.
(4) 在策略模式中利用组合和委托来让Context用于执行算法的能力,这也算是继承的一种更轻便的替代方案

### 6. 代理模式
#### 6.1 保护代理和虚拟代理

虚拟代理就是把一些开销很大的对象,延迟到真正需要它的时候才去创建.

#### 6.2 代理的意义
>> 单一职责原则指的是,对于一个类(通常是对象或者函数等)而言,应该仅有一个引起它变化的原因.
### 7. 迭代器模式

**迭代器模式的定义: 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露该对象的内部表示.**

**只要迭代的聚合对象拥有length属性而且可以用下标访问,那它就可以被迭代.**



### 8. 发布-订阅模式

**发布-订阅模式又称观察者模式,他定义对象间的一对多的依赖关系,当一个对象的状态发生改变时,所有依赖它的对象都将得到通知**

**拥有订阅事件的人就是订阅者,触发订阅时间的人就是发布者.**
**在某些情况下,我们需要先将这条消息保存下来,等到有对象来订阅它的时候.再重新把消息发布给订阅者,如同qq中的离线消息一样,离线消息被保存在服务器中,接收人下次登录上线之后,可以重新收到这条消息.(离线缓存)**
**在javscript中,我们通常选择推模型,即在指定时间发生时,发布者一次性把素有更改的状态和数据都推送给订阅者.**
**发布订阅模式的两个优点: (1) 时间上的解耦 (2) 对象之间的解耦**


### 9. 命令模式

**命令模式指的是一个执行某些特定事情的指令.**

**命令模式的使用场景**
有时候需要向某些对象发送请求,但是并不知道请求的接受者是谁,也不知道被请求的操作是什么,此时希望用一种松耦合的当时来设计软件,使得请求发送者和请求接收者能够消除彼此之间的耦合关系.

>> 设计模式的主题总是把不变的事物和变化的事物分离开


### 10. 组合模式

***组合模式将对象组合成树形结构,以表示"部分-整体"的层次结构.**

**组合模式的用途**
(1) 表示树形结构.
(2) 利用对象多态性统一对待组合对象和单个对象.

**强大的宏命令是指: 最顶层的宏命令会包含另外一些宏命令和普通子命令,看起来是一颗相对复杂的树.**
这样每当对最上层的对象进行一次请求时,实际上是对整个树进行深度优先的搜索.
javascript中实现组合模式的难点在于保证组合对象和叶对象具有相同的方法,组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和也叶对象的区别,但他们本质上是有区别的.

**开放-封闭原则: 对扩展开放,对修改关闭.**

**使用组合模式的一些值得注意的地方**
(1) 组合模式不是父子关系
组合模式只一种HAS-A(聚合)的关系,而不是IS-A,组合对象包含一组叶对象,组合对象只是把请求委托给它做包含的所哟叶对象,他们能够合作的关键适用于相同的接口.

(2) 对叶对象操作的一致性
组合模式除了要求组合对象和叶对象有相同的接口之外,还有一个必要条件,就是对一组叶对象的操作必须具有一致性.

(3) 双向映射关系
为了组合对象中的不同的组合对象中包含相同的叶对象导致操作重复,我们需要给组合对象he叶对象建立双向映射关系,我们可以通过增加集合来保存对方的引用.

(4) 用职责链模式提高组合模式性能

**何时使用组合模式**
(1) 表示对象的部分-整体层次结构
(2) 客户希望统一对待树中的所有对象


### 11. 模板方法模式

所谓的模板方法就是封装了子类的算法框架,它作为一个算法的模板,指导子类以何种顺序执行哪些方法.在摸板方法中,算法中的每一个步骤都清楚滴展示在我们面前.


**抽象类是不能被实例化的,因为它没有指明具体的东西,它只是一类事物的统称.**   

抽象类的第一个作用就是隐藏对象的具体类型

模板方法模式经常拿被架构适用于搭建项目的框架,程序员则负责集成框架的结构,负责往里面填空.

当使用了模板方法模式以后就意味着子类放弃了对自己的控制权,改为父类通知子类哪些方法应该在什么时候调用,作为子类,只负责提供一些设计上的细节.这也就是所谓的好莱坞原则,即高层组件调用底层组件.

>>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式.

### 12. 享元模式

>>享元模式是一种用时间换空间的优化模式,是一种性能优化的模式,在一个存在大量相思对象的系统中,享元模式可以很好的解决大量对象带来的性能问题.享元模式的核心是运用共享技术来有效支持大量细粒度的对象.

**享元模式的通用结构**
只有当某种共享对象被真正需要的时候,它才从工厂中被创建出来.可以用一个管理器来记录对象相关的外部状态,使这些外部状态通过某个钩子和共享对象联系起来.

**享元模式的使用场景**
(1) 一个程序中使用了大量的相思对象
(2) 由于使用了大量对象,造成很大的内存开销
(3) 对象的大多数状态可以变为外部状态
(4) 剥离出对象的外部状态之后,可以用相对较少的共享对象取代大量对象


### 13. 职责链模式

**有时候为了避免代码写的庞大复杂难以维护,我们会按职能将函数拆分.**

**职责链的优缺点**
(1) 优点
优点1: 职责链的最大优点就是解耦了请求发送者和N个接收者之间的复杂关系,由于不知道链中的哪个节点可以处理你发出的请求,所以你只需要把请求传递给第一个节点即可.
优点2: 链中的各个节点有各自的处理函数,且不相互影响.
优点3: 链中的节点可以灵活地拆分和重组,增加或者删除节点,都不会对链中的其他节点造成影响.
优点4: 可以手动置顶其实节点,即请求并不是非要从链中的第一个节点开始传递.

(2) 缺点
缺点1: 我们无法保证请求一定会被链中的节点处理,这样我们可以在链尾额外增加一个节点来处理请求.
缺点2: 程序中可能会多出一些没有起到作用的节点,,我们要避免过长的职责链带来的性损耗.

>> 运用得当的话,职责链模式可以很好的帮助我们管理代码,降低发起请求的对象和处理请求的对象之间的耦合性.

### 14. 中介者模式

**中介者模式的作用就是解除对象与对象之间的紧耦合关系.增加一个中介者对象后,所有的相关对象都通过终结者对向来通信,而不是相互引用,所以当一个对象发生改变时,只需要通知中介者对象即可.中介者使各对象之间耦合松散,而且可以独立地改变他们之间的交互.**

中介者模式使各个对象之间得以解耦,以中介者和对象之间的一对多关系取代了之前的网状多对多关系,每个对象只需要关注自身功能的实现,对象之间的交互关系来交给了中介者对象来实现和维护.这样做有一个弊端就是会使得中介者对象是巨大的,对象自身往往就是一个难以维护的对象.


### 15. 装饰者模式

**需要注意的是,函数被装饰以后,实际上返回的是新增了一些业务逻辑的新的函数,如果原函数上保存了一些属性,那么这些属性会丢失.**

装饰者模式就是一开始对象的行为或者功能可能没有办法定义的很完整,在后续使用的时候需要该对象具有其他的功能,然后又不想违背js的开放-封闭原则,所以此时就采用装饰者模式为对象动态地加入行为.

通过装饰者模式,我们可以将表单验证和表单提交两个行为分离开来.
在编写框架的时候为了让框架有那个更多的功能,省去一些判断,我们可以在相关功能需要的时候在框架之外动态地装饰上去.

### 16. 状态模式

>> 状态模式的关键是区分事物内部的状态,事物内部状态的改变往往带来事物的行为改变.
>> 状态模式的定义: 允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类.

状态模式可以使每一种状态和它对应的行为之间的关系局部化,这些行为被分散和封装在各自对应的状态类之中,便于阅读和管理代码.

**状态模式的优缺点**
(1) 状态模式定义了状态与行为之间的关系,并将它们封装在一个类里.通过增加新的状态类,很容易增加新的状态和切换.
(2) 避免Context无限膨胀,状态切换的逻辑被分布在状态类中,也去掉了Context只能怪原本过多的条件分支
(3) 用对象代替字符串来记录当前状态,使得状态的切换更加一目了然
(4) Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而不互相影响.

**缺点**
(1) 会在系统中定义很多状态类,因此会增加不少对象.
(2) 避开了多条分支语句,将逻辑分散在状态类中,造成了逻辑分散的问题.我们无法在一个地方就看出整个状态机的逻辑.


### 17. 适配器模式

**适配器(别名:包装器)模式的作用就是解决两个软件实体间的接口不兼容的问题.使用适配器模式之后,原本由于接口不兼容 而不能工作的两个软件实体可以一起工作.**

很多模式彼此有很多相似之处,区别它们的关键就是模式的意图

* 适配器模式主要用来解决两个已有接口之间不匹配的问题,他不考虑这些接口是怎样实现的,也不考虑他们将来可能会如何演化.适配器模式不需要改变已有的接口,能够使它们协同作用.
* 装饰者模式和代理模式也不会改变原有对象的接口,但装饰者模式的作用是为了给对象增加功能.装饰者模式常常形成一条常长的装饰链,而适配器通常只包装一次.代理模式是为了控制对对象的访问,通常也只包装一次.
* 外观模式的作用倒是和适配器比较相似,有人把外观模式看成一组对象的是脾气,但是外观模式最显著的特点就是定义了一个新的接口.


## 第三部分 设计原则和编程技巧

### 18. 单一职责原则

>>SPR原则的体现为: 一个对象(方法)只做一件事情
**SPR原则在设计模式中的应用:**

(1) 代理模式
(2) 迭代器模式
(3) 单例模式
(4) 装饰者模式

**怎样分离职责**
(1) 如果随着需求的变化,有两个职责总是同时变化,就不必须分离他们
(2) 如果两个职责已经被耦合在一起,他们没有发生改变的征兆,那么就不必要分离她们.

**SPR原则的优缺点**
(1) 优点是降低了单个类或者对象的复杂度,有利于代码复用和单元测试
(2) 增加了编写代码的复杂度


###19. 最少知识原则

>> 最少知识原则(LKP)是指一个软件实体应当尽可能地少与其他实体发生相互作用,尽量减少对象之间的交互,降低对象之间的耦合度.

外观模式就是为一组子系统提供一个简单便利的访问入口,隔离客户与复杂子系统之间的联系.

### 20. 开放封闭原则

>> 开放-封闭原则的定义: 软件实体(类, 模块, 函数)等应该是可以扩展的,但是不可修改.

**当我们看到一大片的if或者swtich-case语句时,第一时间就应该考虑,是否利用对象的多态性来重构他们.**

实现开放-封闭原则的关键就是找到程序中要发生变化的地方,然后把变化封装起来.
回调函数是一种特殊的挂钩.我们可以把易于变化的逻辑封装在回调函数里,然后把回调函数作为参数传入一个稳定和封闭的函数中.

### 21. 接口和面向接口编程

**接口的三种含义**
(1) 一个库或者模块对外提供了某某接口
(2) 一些语言提供的关键字,比如Java的interface
(3) 我们谈论的"面向接口编程"中的接口

在java语言中,一些类只有通过向上转型才可以在类型监察系统的监视下相互替换使用.

javascript这种弱类型语言的弊端就是在某些时候我们需要手动进行类型检查.
###22. 代码重构

**代码重构的方法**
(1) 提炼函数
也就相当于给函数瘦身,避免过于复杂的函数,我们把各个功能块独立开来防止,可以增强代码的可读性和可维护性.

(2) 合并重复的条件片段
(3) 把条件分支语句提炼成函数
(4) 合理使用循环
有的时候我们可以吧条件分支,放入数组中,然后通过循环遍历来处理.
(5) 提前让函数退出代替嵌套条件分支
做法多是在每个分支内部返回一个函数.
(6) 传递对象参数而不是过长的参数列表
(7) 尽量减少参数数量
(8) 尽量少用三目运算符,这会降低代码的可读性和可维护性
(9) 合理使用链式调用
(9) 分解大类型
把诸多方法放入一个对象中封装起来,在调用的时候传入对应的属性名即可调用对应的方法.
(10) 用return退出多重循环.
