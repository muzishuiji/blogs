# javascript 正则迷你书

## 第一章 正则表达式字符匹配攻略

1. 正则表达式就是匹配模式,要么匹配字符,要么匹配位置.
2. 正则的匹配分为模糊匹配和精确匹配. 而模糊匹配,有两个方向上的"模糊": 横向模糊和纵向模糊.

- 横向模糊

横向模糊指的是,一个正则可匹配的字符串的长度不是固定的,可以是多种情况的.

- 纵向模糊匹配

纵向模糊指的是,一个正则匹配的字符串,具体到某一位字符时,它可以不是某个确定的字符,可以有多种可能.

2. 惰性匹配与贪婪匹配

惰性匹配(尽可能少的匹配), 贪婪匹配(尽可能多的匹配), 默认情况下是贪婪匹配.

| 惰性量词 | 贪婪量词 |
| -------- | -------- |
| {m, n}?  | {m, n}   |
| {m,}?    | {m,}     |
| ??       | ?        |
| +?       | +        |
| \*?      | \*       |

3. 多选分支

一个模式可以实现横向和纵向的模糊匹配.而多选分支可以支持多个子模式任选其一;注意多选分支也有短路匹配的特性,如果第一个子模式已经匹配就会直接返回,不继续匹配后面的子模式.

4. 匹配 16 进制颜色的正则:

   RegExp: /#([0-9A-Fa-f]{6}|([0-9A-Fa-f]{3})/g
   TimeRegExp: /^(0?[0-9]|[1][0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])\$/; // 0 可省略

5. 可以通过设置 [^x]\*, 表示匹配到 x 字符之前的内容


    // 当匹配到双引号之前的内容
    var regex = /id="[^"]*"/
    var string = '<div id="container" class="main"></div>';
    console.log(string.match(regex)[0]);
    // => id="container"

## 第二章 正则表达式位置匹配攻略

ES5 中,共有 6 个锚, ^、\$、\b、\B、(?=p)、(?!p) , 灵活使用这 6 个锚,可以让我们更好的写出符合需求的正则.

1. ^ 和 \$

^: 匹配开头,在多行匹配中匹配开头;
\$: 匹配结尾,在多行匹配中匹配结尾;

2. \b 和 \B

\b: 匹配单词边界;
\B: 匹配非单词边界,夹在单词的字符间的位置;

        var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
        console.log(result);
        // => "[#JS#] #Lesson_01#.#mp4#"
        var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
        console.log(result);
        // => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"

3. (?=p) 和 (?!p) (学名: 正向先行断言,和负向先行断言)

(?=p): 其中 p 是一个子模式,即匹配 p 前面的位置,或者说,该位置后面的字符要匹配 p.

    // 例: (?=l),表示"l"字符前面的位置
    var result = 'hello'.replace(/(?=l)/g, '#');
    console.log(result);
    // => "he#l#lo

(?!p): 匹配不匹配(?=p)的位置,即子模式 p 匹配字符前面的位置之外的位置

    // 例: (?=l),表示"l"字符前面的位置
    var result = 'hello'.replace(/(?!l)/g, '#');
    console.log(result);
    // => "#h#ell#o#

ES5 之后的版本会支持 (?<=p) 和 (?<!p) , 它们 和 (?=p) 和 (?!p) 的区别就是方向不同, 后者是匹配子模式 p 前的字符,前者是匹配子模式后的字符.

4. 位置的特性:

比如 "hello" 字符串等价于如下的形式：

`"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "" + "o" + "";`

字符之间的位置,可以写成多个,可以把位置理解成空字符,一个位置可以匹配多个空字符.所以下面这个复杂的匹配也是返回 true 的.

    var result = /(?=he)^^he(?=\w)llo$\b\b$/.test("hello");
    console.log(result)

> > 把位置理解成空字符,是对位置非常有效的理解方式.

5. 不匹配任何东西的正则: /.^/
6. 数字的千分位分隔符:


    var result = '123456789'.replace(/(?!^)(?=(\d{3})+$)/g, ',');
    console.log(result);  // 123,456,789

如果要把 "12345678 123456789" 替换成 "12,345,678 123,456,789",则需要将正则里面的 ^ 和 结尾 \$,修改成 \b;

    var result = '12345678 123456789'.replace(/(?!\b)(?=(\d{3})+\b)/g, ',');
    console.log(result);  // 12,345,678 123,456,789
    // (?!\b) 也就是 \B
    var result = '12345678 123456789'.replace(/\B(?=(\d{3})+\b)/g, ',');
    console.log(result);  // 12,345,678 123,456,789

我们通常会将子模式用括号括起来.

7.  验证密码: 数字,小写字符和大写字符组成,至少包含两种;

`(?=.*[0-9])` 的意思就是 任意多个字符,后面跟个数字,就是接下来的字符,必须包含数字.

        // 两种字符组合
        var regExp = /(?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z])^[0-9a-zA-Z]{6,12}/
        // 不能全部都是数字/大写字母/小写字母
        var regExp = /(?!^[0-9])(?!^[a-z])|(?!^[0-9])(?!^[A-Z])|(?!^[a-z])(?!^[A-Z])^[0-9a-zA-Z]{6,12}/

## 第三章 正则表达式括号的作用

### 3.1 分组和分支结构
