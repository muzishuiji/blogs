# passive的作用与原理

## passive 到底有什么用？

passive主要用于优化浏览器页面滚动的性能，让页面滚动更顺滑。

## passive 产生的历史时间线

`addEventListener()`：为dom添加触发事件

早期的addEventListener是这样的：

`addEventListener(type, listener, useCapture)`

useCapture: 是否允许事件捕捉，很少会传true，然后就变成可选项了

现在的addEventListener是这样的：

```javascript
addEventListener(type, listener, {
    capture: false, // 是否在捕获阶段触发
    passive: false, 
    once: false  // 只触发一次
})
```

## passive为什么能优化页面的滚动性能？

**chrome的线程化渲染框架的两个线程**

* 内核线程（Main/Render Thread）：负责DOM树的构建，元素的布局，图层绘制记录部分，js的执行

这也就是为什么js的执行会阻塞dom渲染的原因，这整个流程是串行执行的。

* 合成线程（Compositor Thread）： 图层绘制实现部分（impl-side），图层图像合成（这样就是动画渲染的优化策略，构建形成层，在另一个线程处理，缓解主线程压力。）

页面在内核线程完成js执行，布局和绘制后，经过一个周期合成线程去执行页面图像的合成。

**用户输入事件分类**

* 在内核线程处理的事件

* 直接由合成线程处理的事件

那么是内核线程处理事件还是合成线程处理事件有什么区别呢？

在内核线程处理的事件： 需要经过内核线程处理的输入事件要在内核线程执行逻辑，遇到内核线程在忙，无法立即响应，比如用户的大部分输入事件都跟页面元素有关系，一旦页面元素注册了对应事件的监听器，监听器的逻辑代码必须在内核线程中执行（V8引起运行在内核线程），因此这种输入事件经常无法立即得到响应。

直接由合成线程处理的事件： 不经过内核线程能快速处理的输入事件为手势输入事件（滑动，捏合）

**虽然手势事件不能在内核线程处理，但是手势事件的产生还是离不开内核线程**


## 页面卡顿的原因

手势事件有个属性 cancelable，作用是告诉浏览器该事件是否允许监听器通过 preventDefault() 方法阻止，默认为true。如果touch事件内部调用 preventDefault()，事件默认行为被取消，页面也静止不动了。但是浏览器不知道touch事件内部是否调用了preventDefault()，**浏览器只有等内核线程执行到事件监听器对应的js代码时，才知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身无法优化这种场景。**手势输入事件是由连续的普通输入事件组成的，在这种场景下，无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感到页面卡顿。

而chrome团队从统计数据分析得出，注册了mousewheel/touch的相关事件监听器的页面中，80%的页面内部都不会调用 preventDefault行为来阻止事件的默认行为。对于这80%的叶脉呢即使监听器内部什么都没有做，相对没有注册mouse/wheel/touch事件监听器的页面，在滑动流畅度上，由10%的叶脉呢增加至少100ms的延迟，1%的页面增加500ms以上的延迟。对于这些页面来说，他们是不希望因为注册mousewheel/touch相关的事件监听器而导致滑动延迟增加的。

## passive的诞生

passive的意思是顺从的，表示它不会对事件的默认行为说no，浏览器知道了一个监听器是passive的，它就可以在两个线程里同时执行监听器的JavaScript代码和浏览器的默认行为了，这样使得滚动行为可以更流畅的执行。

passive实际上是为了解决浏览器页面滚动流畅度而设计的，它通过扩展时间属性passive让web开发者告知浏览器是否阻止默认行为，从而让浏览器能够更智能的决策优化，这其中涉及到chrome的多线程渲染框架，输入事件处理等知识。
