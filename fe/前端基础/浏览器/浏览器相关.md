## V8引擎机制
1. V8引擎如何执行一段JS代码
    1. 预解析：检查语法错误但不生成AST；
    2. 生成AST：经过词法/语法解析，生成抽象语法树；
    3. 生成字节码：基线编译器（Ignition）将AST转换成字节码；
    4. 生成机器码：优化编译器（Turbofan）将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么V8会将这段代码直接转换成机器码存储起来，下一次执行就不必经过字节码，优化了执行速度；

2. 引用计数和标记清除

    - 引用计数：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
    - 标记清除：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

3. V8如何进行垃圾回收

JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存存储引用类型的数据。
![alt text](image.png)

**栈内存的回收：**
栈内存调用栈上下文切换就被回收，比较简单

**堆内存的回收：**
V8的堆内存分为新生代内存和老生代内存，新生代内存时临时分配的内存，存在时间短，老生代内存存在时间长。
![alt text](image-1.png)

    - 新生代内存回收机制：
        - 新生代内存容量小，64位系统下仅有32M。新生代内存分为From，To两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收。
    - 老生代内存回收机制：
        - 晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中；
        - 标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象；
        - 整理内存碎片：把对象挪到内存的一端；

[聊聊V8引擎的垃圾回收](https://juejin.cn/post/6844903591510016007#heading-10)

4. JS相较于C++等语言为什么慢，V8做了哪些优化
    1. js的问题：
        - 动态类型：导致每次存取属性/寻求方法的时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化；
        - 属性存取：c++/java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而js存储在对象中，每次获取都要进行哈希查询。
    2. V8的优化：
        - 优化JIT（即时编译）：相较于c++/java这类编译型语言，js一边解释一遍执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。
        - 隐藏类：对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而js需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类；
        - 内嵌缓存：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址->根据属性名查找偏移值->计算该属性地址，内嵌缓存就是这一过程结果的缓存。
        - 垃圾回收管理：上文已介绍
![alt text](image-2.png)

## 浏览器调试

1. 设置断点（break point）
在chrome devtools中，你可以在源代码中设置断点，以暂停嗲吗执行。设置断点的方式有几种：
    - 点击行号左侧：在源代码视图的左侧空白区域点击，会在当前行设置一个断点。断点通常用一个小红圈表示；
    - 右键点击行号：右键点击行号，选择“toggle breakpoint”来设置或取消断点；
    - 使用debugger语句；在代码中插入debugger语句，当代码执行到这一行会自动暂停；
2. 断点控制按钮
一旦设置了断点并开始调试，你会看到几个主要的断点控制按钮：
    - Resume Script Execution（F8）:继续执行（F8）
        - 这个按钮通常表示为一个蓝色箭头，点击后会继续执行代码直到下一个断点或代码执行完毕。
    - Step Over Next Function Call（F10）：单步执行、步过（F10）
        - 步过按钮表示为一个蓝色箭头，点击后会执行当前的代码，但不会进入函数调用。如果当前行是一个函数调用，则会跳过该函数体内的代码。

    - Step Into Next Function Call（F11）： 步入（F11）
        - 步入按钮表示为一个向下的箭头，点击后会进入当前函数的调用。如果当前行是一个函数调用，则进入该函数体内进行逐行调试（步过调试）。
    - Step Out of Current Function Call(shift+F11): b步出（shift+F11）
        - 步出按钮是一个向上的箭头，点击后会退出当前的函数并继续执行外部的代码。

3. 断点条件设置
出了基本的断点设置外，Chrome DevTools还允许你为断点设置条件。
    - 条件断点：可以在断点处设置条件表达式，只有当条件满足时，断点才会激活，如：设置x>10作为断点条件。
    - Log Point：可以在断点处记录变量的值，当代码执行到断点时，会在控制台输出指定的信息。

4. 断点的管理

    - 断点列表：在Sources面板中，你可以查看当前设置的所有断点，并对其进行管理；
    - 禁用/启用断点：可以临时禁用某个断点，而不需要删除它。右键点击断点图标，选择“Disable Breakpoint”禁用断点或者“Enable Breakpoint”启用断点；
    - 删除断点：同样可通过右键菜单选择“Remove Breakpoint”移除断点来删除一个断点；

## 浏览器的5种observer
1. IntersectionObserver
IntersectionObserver可以jian ting一个元素和可视区域相交部分的比例，然后在可视比例达到某个阈值的时候触发回调；

使用场景：当我们做一些数据采集的时候，可以利用这个api知道某个元素是否是可见的，什么时候可见。做图片/列表懒加载的时候，可以设置可视比例达到某个值后触发加载。

2. MutationObserver
MutationObserver可以监听对元素的属性的修改、对它的子节点的增删改。

使用场景：文章水印被人通过devtools去掉了，就可以通过MutationObserver监听这个变化，然后重新加上。

3. ResizeObserver
ResizeObserver可以监听元素大小的改变，当width、height被修改时触发回调。

4. PerformanceObserver
PerformanceObserver用于监听performance数据的行为，一旦记录了就会触发回调，这样我们就可以在回调里把这些数据上报。
创建PerformanceObserver对象，监听mark（时间点）、measure（时间段）、resource（资源加载耗时）这三种记录时间的行为。
mark记录一个时间点，measure记录一个时间段。利用这个api，可以很方便的做性能分析。

5. ReportingObserver
浏览器提供PerformanceObserver的api用来监听过时的api、浏览器干预等报告的打印，在回调里上报，这些事错误监听无法监听到但对了解网页运行情况很有用的数据。
    - 当浏览器运行到过时（deprecation）的api的时候，会在控制台打印一个过时的报告；
    - 浏览器会在一些情况下把cpu占用太多的iframe删掉；
    - 浏览器会在网络比较慢的时候把图片替换为占位图片，点击才会加载；









