[浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)

1. 浏览器的渲染过程是怎样的
![alt text](./images/render.png)
大体流程如下：
- HTML和CSS经过各自解析，生成DOM树和CSSOM树
- 合并成为渲染树
- 根据渲染树进行布局
- 最后调用GPU进行绘制，显示在屏幕上

2. 如何根据浏览器渲染机制加快首屏速度?

  1. 优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度
  2. 避免资源下载阻塞文档解析：浏览器解析到<script>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把<script>标签放在底部，或者加上defer、async来进行异步下载
  3. 采用ssr
  4. 预渲染pre-rendering

3. 即使频繁的触发dom操作，浏览器也不会频繁的执行渲染，浏览器会按照帧周期进行优化，合并多次更新操作以减少性能开销。

```js
setInterval(() => {
  document.body.style.backgroundColor = 
    document.body.style.backgroundColor === 'red' ? 'blue' : 'red';
}, 10)
```

4. 浏览器渲染时机的优化策略：

现代浏览器会在某些特定时机触发渲染，以保证性能和流畅性，同时避免不必要的频繁渲染：
  1. 任务完成后检查渲染需求：
    - 在宏任务执行完毕且微任务队列清空后，浏览器会检查页面是否标记为“需要更新”（dirty flag）；
    - 如果有更新需求，浏览器会立即触发渲染流程；
  2. 渲染合并优化：
    - 浏览器会将多个dom更新操作合并为一次渲染，以减少不必要的重排和重绘；
    - 这种优化称为布局合并或批量更新；
  3. 渲染帧周期：
    - 浏览器通常尝试以60fps（每帧16.66ms）的频率进行渲染；
    - 如果帧周期内任务队列空闲，浏览器会利用这个空闲时间触发渲染；

5. 事件循环执行流程与浏览器渲染

  1. 执行一个宏任务（同步代码，或者setTimeout完成后的回调）；
  2. 执行微任务队列中的所有任务；
  3. 如果主线程空闲，且有更新需求，则进行渲染；

6. 渲染发生的具体时机：

  1. 当前宏任务执行完毕：浏览器会先执行当前宏任务中的所有代码；
  2. 清空微任务队列：宏任务执行完毕后，浏览器会处理微任务队列（如promise.then等微任务）；
  3. 主线程空闲且允许渲染：如果此时没有更多的js任务需要执行，并且渲染任务被标记为需要更新，浏览器会进入渲染流程；

7. 渲染不会在以下情况下立即触发：

  1. js执行过程中：
    - 浏览器不会中断js执行去渲染页面（js执行和浏览器渲染是互斥的，互相阻塞）；
    - 连续的dom操作会被推迟到当前任务执行完后再渲染；
  2. 事件循环忙碌时：
    - 如果任务队列中有大量微任务或者耗时的宏任务，渲染可能会被推迟到处理完毕（这样就会掉帧，在用户侧表现卡顿）；

8. 常见的渲染触发时机：

浏览器会在以下阶段尝试进行渲染：
  - 宏任务与微任务完成后：
    - 例如在setTimeout、requestAnimationFrame回调或其他事件回调执行完毕后；
  - 帧刷新周期到来时：
    - 浏览器会尝试每16.6ms渲染一次；
    - 如果上一帧更新后没有新的渲染任务，浏览器可能跳过帧的渲染；
  - 用户交互事件：如输入事件，滚动或窗口大小调整等
  - 显示属性变化：如display、visibility等；
  - 强制同步布局或重绘：
  可以通过访问会触发回流的属性，如offsetHeight等来强制浏览器执行布局或重绘。

9. 页面拿到资源后的流程

  1. 解析阶段（parsing）
    - HTML解析
      - 词法分析：将HTML字符串分解为token（标签、属性、文本等）；
      - 语法分析：根据HTML语法规则解构DOM树；
      - DOM树构建：创建文档对象模型，表示页面的结构；
    - CSS解析
      - CSS解析：解析CSS文件，构建CSSOM树；
      - CSSOM树：包含所有CSS规则和样式信息；
  2. 渲染树构建（Render Tree）
    - 合并DOM和CSSOM：将DOM树和CSSOM树合并成渲染树；
    - 过滤不可见元素：移除display:none,head等不可见元素；
    - 计算样式：应用CSS规则，计算每个元素的最终样式；
  3. 布局阶段（Layout/Reflow）
    - 计算几何信息：确定每个元素在是视口中的确切位置和大小；
    - 盒模型计算：计算margin、border、padding、content的尺寸；
    - 定位计算：处理相对定位、绝对定位、浮动等；
  4. 绘制阶段（Painting）
    - 分层处理：将页面分为多个图层；
    - 绘制命令：生成绘制命令列表；
    - 光栅化：将矢量图形转换为像素；
  5. 合成阶段（Compositing）
    - 图层合并：将多个图层合称为最终图像；
    - GPU加速：利用GPU进行硬件加速渲染；

> 分层确实可以提高性能，但在内存管理方面成本较高，因此不应作为web性能优化策略过度使用。

10. 预加载扫描器

浏览器构建DOM树时，这个过程占用了主线程。同时，预加载扫描器会解析可用的内容并请求高优先级的资源，如css、js、web字体等，预加载扫描器使得我们不必等到解析器找到对外资源的引用时才去请求。他将在后台检索资源，而当主html解析器解析到要请求的资源时，它们可能已经在下载中了，或者已经被下载。预加载扫描器提供的优化减少了阻塞。

11. 构建CSSOM

构建CSSOM树是非常快的，创建CSSOM的总时间通常小于一次DNS查询所需的事件。

12. 预解析

预解析线程：浏览器使用预解析线程来下载和解析CSS、图片资源，主线程继续解析HTML。
图片和css资源的下载都是异步进行的，所以都不会阻塞HTML的解析；
但css会阻塞渲染，因为渲染树的合成需要等待CSSOM构建完成；
图片：既不阻塞HTML解析，也不阻塞渲染（可能会在宽高未指定的情况下，加载完毕后触发重排）