[浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)

1. 浏览器的渲染过程是怎样的
![alt text](./images/render.png)
大体流程如下：
- HTML和CSS经过各自解析，生成DOM树和CSSOM树
- 合并成为渲染树
- 根据渲染树进行布局
- 最后调用GPU进行绘制，显示在屏幕上

2. 如何根据浏览器渲染机制加快首屏速度?

  1. 优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度
  2. 避免资源下载阻塞文档解析：浏览器解析到<script>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把<script>标签放在底部，或者加上defer、async来进行异步下载
  3. 采用ssr
  4. 预渲染pre-rendering

3. 即使频繁的触发dom操作，浏览器也不会频繁的执行渲染，浏览器会按照帧周期进行优化，合并多次更新操作以减少性能开销。

```js
setInterval(() => {
  document.body.style.backgroundColor = 
    document.body.style.backgroundColor === 'red' ? 'blue' : 'red';
}, 10)
```

4. 浏览器渲染时机的优化策略：

现代浏览器会在某些特定时机触发渲染，以保证性能和流畅性，同时避免不必要的频繁渲染：
  1. 任务完成后检查渲染需求：
    - 在宏任务执行完毕且微任务队列清空后，浏览器会检查页面是否标记为“需要更新”（dirty flag）；
    - 如果有更新需求，浏览器会立即触发渲染流程；
  2. 渲染合并优化：
    - 浏览器会将多个dom更新操作合并为一次渲染，以减少不必要的重排和重绘；
    - 这种优化称为布局合并或批量更新；
  3. 渲染帧周期：
    - 浏览器通常尝试以60fps（每帧16.66ms）的频率进行渲染；
    - 如果帧周期内任务队列空闲，浏览器会利用这个空闲时间触发渲染；

5. 事件循环执行流程与浏览器渲染

  1. 执行一个宏任务；
  2. 执行微任务队列中的所有任务；
  3. 如果主线程空闲，且有更新需求，则进行渲染；

6. 渲染发生的具体时机：

  1. 当前宏任务执行完毕：浏览器会先执行当前宏任务中的所有代码；
  2. 清空微任务队列：宏任务执行完毕后，浏览器会处理微任务队列（如promise.then等微任务）；
  3. 主线程空闲且允许渲染：如果此时没有更多的js任务需要执行，并且渲染任务被标记为需要更新，浏览器会进入渲染流程；

7. 渲染不会在以下情况下立即触发：

  1. js执行过程中：
    - 浏览器不会中断js执行去渲染页面（js执行和浏览器渲染是互斥的，互相阻塞）；
    - 连续的dom操作会被推迟到当前任务执行完后再渲染；
  2. 事件循环忙碌时：
    - 如果任务队列中有大量宏任务和微任务，渲染可能会被推迟到处理完毕（这样就会掉帧，在用户侧表现卡顿）；

8. 常见的渲染触发时机：

浏览器会在以下阶段尝试进行渲染：
  - 宏任务与微任务完成后：
    - 例如在setTimeout、requestAnimationFrame回调或其他事件回调执行完毕后；
  - 帧刷新周期到来时：
    - 浏览器会尝试每16.6ms渲染一次；
    - 如果上一帧更新后没有新的渲染任务，浏览器可能跳过帧的渲染；
  - 用户交互事件：如输入事件，滚动或窗口大小调整等
  - 显示属性变化：如display、visibility等；
  - 强制同步布局或重绘：
  可以通过访问会触发回流的属性，如offsetHeight等来强制浏览器执行布局或重绘。

9. 页面拿到资源后的流程

  - 解析css形成cssom；
  - 解析dom树形成dom tree；
  - 根据dom树和cssom树生成布局树（layout tree）;
  - 浏览器会讲布局树中的元素转换为绘制记录，记录每个元素的绘制顺序和绘制指令；
  - 合成（composite）：合成涂层，浏览器会将多个图层合成为最终的页面图像。如果开启了3d加速，浏览器会将图层上传到GPU，利用GPU的并行计算能力进行合成和渲染；

> 分层确实可以提高性能，但在内存管理方面成本较高，因此不应作为web性能优化策略过度使用。


10. 预加载扫描器

浏览器构建DOM树时，这个过程占用了主线程。同时，预加载扫描器会解析可用的内容并请求高优先级的资源，如css、js、web字体等，预加载扫描器使得我们不必等到解析器找到对外资源的引用时才去请求。他将在后台检索资源，而当主html解析器解析道要请求的资源时，它们可能已经在下载中了，或者已经被下载。预加载扫描器提供的优化减少了阻塞。

11. 构建CSSOM

构建CSSOM树是非常快的，创建CSSOM的总时间通常小于一次DNS查询所需的事件。