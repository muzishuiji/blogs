# js的静态作用域链与动态闭包链


## 静态作用域链

```JavaScript
  function func() {
    const guang = 'guang';
    function func2() {
      const ssh = 'ssh';
      {
        function func3 () {
          const suzhe = 'suzhe';
        }
      }
    }
  }
```

函数和块的作用域内的变量生命会在作用域(scope)内创建一个绑定(变量名绑定到具体的值,也就是binding),然后其余地方可以引用(refer)这个binding.

这样就是静态作用域链的变量访问顺序.即某个函数能访问另一个函数作用域内的变量就是有了这个函数作用域内变量的引用.

**为什么是静态作用域呢?**

因为这样的引用关系是函数定义的时候就可以确定的,不需要运行,按照这种顺序访问变量的链就是静态作用域链,这种链的好处就是可以直观的知道变量之间的引用关系.

如果设计成动态的,应该会增加代码的不可控性.动态作用域链,也就是作用域链的引用关系和嵌套关系无关,与执行顺序有关,会在执行的时候动态创建不同函数,

块的作用域的引用关系.缺点就是不直观,没法静态分析.静态作用域可以在编译的时候就函数作用于之间的变量引用关系确定出来.

JavaScript除了静态作用域外,还有一个特点就是可以作为返回值,比如:


```JavaScript
  function func() {
    const a = 1;
    return function() {
      console.log(a)
    }
  }
```

正常情况下的嵌套,我们会按照顺序创建和销毁作用域,但是如果内层函数被返回出去,肯这样外层函数调用完毕后,因为内层函数引用了变量a,但是内层函数又没有调用完毕,

所以我们会保留内层函数对变量a的引用,且不会销毁变量a占用的内存,保证内层函数被调用时的正常的变量访问.

父函数调用结束,子函数还未调用,但又不能销毁父作用域,这会对未来调用子函数造成影响,所以要在创建个对象,要把子函数内引用的父作用域的变量打包,给子函数带走.

**销毁父作用域后,把用到的变量包起来,打包给子函数,放到一个属性上,这就是闭包的机制.**

打包的数据会被放在函数的 `[[scopes]] `属性上,闭包至少会包含全局作用域,`[[scopes]] `只会保存外部应用

这些外部引用在创建函数的时候保存到函数属性上,创建的函数返回的时候会打包给函数,但是js引擎怎么知道它要用到哪些外部引用呢,需要做AST扫描,很多JS引擎会做
Lazy Parsing,这时候去parse函数,正好也能知道它用到了那些外部引用,然后把这些外部引用打包成Closure闭包,加到[[scopes]]中



**eval**

eval因为没法静态分析动态内容所以会将传入的动态内容全部打包成闭包,本来闭包是为了不保存全部的作用域链的内容,如果eval全不保存了,

这就会导致了保存过多无用的变量,浪费内存.

eval中传入的函数存在的闭包要么全部打包,要么不生成闭包,主要是因为js没有办法做作用域的动态分析,类似webpack的import没办法动态分析一样.

**闭包的缺点**

父函数销毁, 栈帧对应的内存马上释放,用到的ssh obj会被gc会受,而返回的函数会把函数作用域链过滤出用到的引用形成闭包链放在堆中.这就导致了一个隐患: 

如果一个很大的对象被函数引用,本来函数调用结束就能销毁,但是现在引用却被通过闭包保存在了堆里,而且还一直用不到,那这块堆内存就一直没法使用.

严重到一定程度就有可能导致内存泄漏,所以要合理使用闭包.


## 总结

闭包就是可以访问外层作用域中变量的函数. 作用域链就是函数的 `[[scopes]] ` 可访达的内容.




