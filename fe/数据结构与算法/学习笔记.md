
# 秘诀

先不要着急写代码，静下心来，稳住神，一步一步理清自己的思路，然后再开始写代码。

## 数组、链表
1. js中如果声明了非纯数字数组，则js数组不再具有数组的特征，对应的是一段非连续的内存，其底层使用哈希映射分配内存空间，是由对象链表来实现的。

```js
const arr = ['haha', 1, {a: 1}]

```
2. 数组的查询的时间复杂度较低（O(1)），但添加/删除的时间复杂度较高（O(n)）。

3. 链表查询的时间复杂度较高（O(n)），但添加/删除的时间复杂度较低（O(1)）。

4. 遇到“有序”和“数组”立马就想到双指针法，普通双指针走不通，立刻想到对撞双指针。

5. 如果题目中没有给出“有序”的关键条件，我们发觉普通思路走不下去的时候，可以尝试将数组排序，看看有没有新的切入点。

## 栈、队列

1. 若题目中涉及括号问题，则很有可能跟栈有关。

## DFS、BFS

> 看到所有、枚举要想到dfs、bfs。

1. 深度优先搜索过程可以转化为一系列的入栈、出栈操作，在DFS中，我们往往使用递归来模拟入栈、出栈的逻辑。

递归就是选择道路的过程，而递归边界就是死胡同。
- 函数调用的底层，仍然用栈来实现的。JS会维护一个叫函数调用栈的东西，DFS每次调用一次自己，相关调用的上下文会被push进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被pop出来。以昵称，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。
- 其次，DFS作为一种思想，它和树的递归遍历一脉相承、却不能完全的画上等号。DFS的解题场景其实有很多，其中有一类会要求我们记录每一层递归里路径的状态，此时会强依赖栈结构。

2. 对于BFS，先访问的节点会先丢弃，这个顺序很符合“先进先出”的原则，因此整个BFS算法的实现过程，和队列有着密不可分的关系。

## 递归、回溯

1. 当分析题意中会触发不断的重复做某个逻辑，则需要把递归从你的大脑内存中调度出来。
2. 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试试。
3. 不问解的内容，只问解的个数。这类问题往往不用DFS来解，而是用动态规划。
4. 回溯解法的基本范式：

```js
function xxx() {
    const path = [];
    const dfs = (递归参数) {
        if(到达了递归边界) {
            收集回溯的结果
            return;
        }
        for(遍历坑位的可选值) {
            path.push(选择当前值)
            dfs(下一层)
            // 撤销选择
            path.pop()
        }
    }
    dfs()
}
```

## 树

1. 一个节点开叉出去多少个子树，被记为节点的度。

2. 叶子节点就是度为0的节点。

3. 千万不要沉溺在：我看懂了，我理解了，我知道你说的是啥意思了，这种虚无的成就感中，假的，都是假的，只有自己写出来的代码才是真的。

4. 🌲的遍历一定是“左子树”先于“右子树”，遍历的先中后，指的是根节点的先中后。

```js
const root = {
    val: "A",
    left: {
        val: "B",
        left: {
            val: "D"
        },
        right: {
            val: "E"
        }
    },
    right: {
        val: "C",
        right: {
            val: "F"
        }
    }
}
```

5. 二叉搜索树

二叉搜索树是一棵由根节点、左子树、右子树组成的树，同时左子树和右子树都是二叉搜索树，且左子树上所有节点的数据域都小于等于根节点的数据域，右子树上所有节点的数据域都大于等于根节点的数据域。

6. 二叉树的高频操作
  
  - 查找数据域为某一特定值的节点；
  - 插入新节点；
  - 删除指定节点；

7. 一个非常重要的信息：二叉树的中序遍历是有序的！！！

8. 平衡二叉树：平衡二叉树（又称AVL树）指的是任意节点的左右子树高度差绝对值都不大于1的二叉搜索树。

9. 平衡二叉树的查询效率比非平衡二叉树的效率高，二叉搜索树的妙处在于它把二分这种思想以书结构的形式表达了出来。

非平衡二叉树的查询的时间复杂度是O(n)，而二叉搜树，借助二分思想，查找的时间复杂度仅为O(logn)。

10. 当题目中出现第k大，第k高这样的关键字时，就是在暗示你用优先级队列/堆的结构来做题，这样的手法可以允许我们在不对序列进行完全排序的情况下，找到第k个最值。

