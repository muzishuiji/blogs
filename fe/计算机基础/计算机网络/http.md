# 精读图解 HTTP

## 第 1 章 了解 Web 及网络基础

### 1.1 使用 HTTP 协议访问 Web

1. 浏览器中输入 URL,web 页面时如何呈现的?

2. Web 使用一种名为 HTTP 的超文本传输协议作为规范,完成从客户端到服务器端等一系列运作流程.而协议是指规则的约定,Web 是建立在 HTTP 协议上通信的.

## 1.2 HTTP 的诞生

1. WWW(World Wide Web, 万维网)

WWW 最开始提出是为了全世界的研究者们的知识共享.

2. 三种 WWW 构建技术

- SGML(Standard Generalized Markup Language, 标准通用标记语言)
- HTML(作为页面的文本标记语言,HyperText Markup Language, 超文本标记语言)
- URL(指定文档所在地址的 URL, Uniform Resource Locator, 统一资源定位符)

3. HTTP 的版本演进

- HTTP/0.9

HTTP 于 1990 年问世,那时的 HTTP 并没有作为真正的标准被建立,现在的 HTTP 其实是含有 HTTP1.0 之前版本的意思,因此被称为 HTTP/0.9.

- HTTP/1.0

HTTP 正是作为标准被公布狮子啊 1996 年的 5 月,版本被命名为 HTTP/1.0,并记载于 RFC1945,虽是初期版本,但该协议标准至今仍被广泛使用在服务器端.

- HTTP/1.1

1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本,当初的标准是 RFC2068,之后的修订版是 RFC2616.

4. 网络基础 TCP/IP

- TCP/IP

计算机与网络设备要相互通信,双方就必须基于相同的方法.比如,如何探测到通信目标,由哪一边先发起通信,使用哪种语言进行通信,怎样结束通信等规则都需要事先确定,不同的硬件,操作系统之间的通信,所有的通信都需要一种规则,我们称这种规则为协议.

TCP/IP 是互联网相关的各类协议族的总称

5. TCP/IP 的分层管理

TCP/IP 协议族中重要的一点就是分层,TCP/IP 协议族按层次分为一下四层: 应用层,传输层,网络层和数据链路层.

TCP/IP 协议族各层的作用如下:

- 应用层

应用层决定了向用户提供应用服务时通信的活动(HTTP 协议也处于该层).

- 传输层

传输层对上层应用层,提供处于网络连接中的两台计算机之间的数据传输.

在传输层有两个性质不同的协议, TCP(传输控制协议)和 UDP(用户数据报协议).

- 网络层

网络层用来处理网络上流动的数据包,数据包时网络传输的最小数据单位,该层规定了通过怎样的路径到达对方计算机,并把数据包传送给对方.

在多条数据传输线路之间选择一条传输路线.

- 链路层

用来处理连接网络的硬件部分.包括控制操作系统,硬件的设备驱动,NIC(网络适配器),及光纤等物理可见部分,硬件上的范畴均在链路层的作用范围之内.

利用 TCP/IP 协议族进行网络通信时,会通过分层顺序与对方进行通信,发送端从应用层往下走,接收端从链路层往上走.

拿客户端想要看某个 HTTP 页面的请求为例来描述这个过程:

- 第一步: 应用层发起一个 HTTP 请求(HTTP 协议)
- 第二部: 在传输层(TCP 协议)把应用层处收到的数据(HTTP 请求报文)进行分割,并在各个报文上打上标记序号及端口号后转发给网络层.
- 在网络层(IP 协议),增加作为通信目的地的 MAC 地址后转发给链路层.到这里,发送网络请求的准备就做完了
- 服务器端在链路层接收到数据,按需往上层传送,直到应用层,才真正哪都客户端发送过来的 HTTP 请求.

发送端在层与层之间传输数据时,没经过一层就会为其加上该层所属的首部信息,反之,接收端在层与层传输数据时,每经过一层都会去除对应的首部信息.

6. 与 HTTP 关系密切的协议: IP, TCP 和 DNS

- IP 协议

IP 协议的作用就是把各种数据包传送给对方,发送方并不知道准确的网络传输路线,因为中间会经过很多中转站,中转设备通过 MAC 地址来搜索中转目标通过 ARP 协议(解析地址的协议)查找目标设备的 MAC 地址,没有设备知道具体的传输流程,就像寄快递一样,中途会有很多分发站,直至抵达最终的目的地.

- 确保可靠性的 TCP 协议

TCP 位于传输层,提供可靠的字节流服务,简单来说就是把大数据分割,而且 TCP 协议能够确认数据是否准确无丢失的发送到对方.

三次握手: 发送端先发送一个带 SYN 标志的数据包给对方,接收端接收到后,回传一个带有 SYN/ACK 标志的数据包以示传达确认信息,最后发送端在回传一个带 ACK 标志的数据包,以表示握手结束.

若握手的过程中断,TCP 协议会再次以相同的顺序发送相同的数据包.

- 负责域名解析的 DNS 服务

DNS 服务是和 HTTP 协议一样位于应用层的协议,它提供域名到 IP 地址之间的解析服务.

7. URI 和 URL

URI 是某一互联网资源的标识, URL 表示资源的地点(互联网上所处的位置), URL 是 URI 的子集.

URI 的格式

协议(方案名)-登录信息(认证)-服务器地址-服务器端口号-带层次的文件路径-查询字符串-片段标识符

## 第 2 章 简单的 HTTP 协议

1. HTTP 协议用于客户端与服务器之间的通信

请求报文 = 请求方法 + 请求 URI + 协议版本 + 可选的首部字段 + 内容实体

响应报文 = 协议版本 + 状态码 + 状态码的原因短语 + 响应首部字段 + 响应主体

2. HTTP 是不保存状态的协议

HTTP 是一种不保存状态,即无状态协议,HTTP 协议自身不对请求和响应之间的通信状态进行保存.如此设计是为了更快的处理大量事务,确保协议的可伸缩性.后期为了实现保持状态的功能,引入了 Cookie 技术,cookie 可以用来保存一些登录信息.

3. 请求 URI 定位资源

4. 告知服务器意图的 HTTP 方法

- GET: 获取资源,GET 放啊用来请求访问已被 URI 识别的资源.
- POST: 传输实体主体,主要用来做数据修改
- PUT: 传输文件

鉴于 HTTP/1.1 的 put 方法自身不带验证机制,任何人都可以上传文件,存在安全性问题,因此一般的 web 网站不使用该方法,若配合 web 应用程序的验证机制,或架构设计采用 REST 标准的同类 web 网站,就可能会开发使用 put 方法.

- HEAD: 获取报文首部

和 GET 方法一样,只是不返回报文主体部分,用于确认 URI 的有效期,资源大小,以及资源的更新日期等.

- DELETE: 删除文件

DELETE 方法用来删除文件,是与 PUT 相反的方法,DELETE 方法按请求 URI 删除指定的资源.

- OPTIONS: 询问支持的方法

OPTIONS 用来查询对请求 URI 指定的资源支持的方法.

- TRACE: 追踪路径

TRACE 方法是让 web 服务器将之前的请求通信还回给客户端的方法(用于追踪请求路径)

- CONNECT: 要求用隧道协议连接代理

CONNECT 方法要求在与代理服务器通信时建立隧道,实现用隧道协议进行 TCP 通信.主要使用 SSL(安全套接层)和 TSL(传输层安全)协议把内容加密后经网络隧道传输.

5. 持久连接

为了解决大量的资源传输导致频繁的建立连接,造成时间和宽带资源的浪费,HTTP/1.1 推出啦 HTTP keep-alive 或 HTTP connection reuse 的方法,持久连接的特点是: 只要任意一端没有明确提出断开连接,则保持 TCP 的连接状态.

6. 管线化

管线化指的是客户端可以同时并行发送多个请求,而不需要一个接一个的等待响应.

7. Cookie

由于 HTTP 的无状态,所以引入了 Cookie 来保存客户端的状态.在实际的开发中,我们通常使用 cookie 来存储用于验证用户身份信息的 token,客户端和服务器使用这个 token 来校验用户的登陆状态.

## 第 3 章 HTTP 报文内的 HTTP 信息

### 3.1 HTTP 报文

用于 HTTP 交互的信息被称为 HTTP 报文,HTTP 报文分为请求报文和响应报文,本身是有多行数据构成的字符串文本. HTTP 报文 = 报文首部 + 空行 + 报文主体

### 3.2 编码提升传输速率

HTTP 在传输数据时可以按照数据原貌直接传输,但也可以在传输过程中通过编码提升传输速率.通过在传输时编码,能更快速的处理大量的访问请求,但是,编码的操作需要由计算机来完成,因此会消耗更多的 CPU 资源.

1. 报文主题和实体主体的差异

- 报文

是 HTTP 通信的基本单位,由 8 位组字节流（octet sequence，
其中 octet 为 8 个比特）组成,通过 HTTP 通信传输.

- 实体

作为请求或响应的有效载荷数据(补充项)被传输,其内容由实体首部和实体主体组成.

HTTP 报文的主体用于传输请求或响应的实体主体,报文主体就是实体主体或者是编码后的实体主体.

2. 压缩传输的内容编码

内容编码指明应用在实体内容上的编码格式,并保持尸体信息原样压缩,内容编码后的实体由客户端接收并负责解码. 内容编码的方式: gzip, compress, deflate, identify

3. 分割发送的分块传输编码

在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。把实体主体分块的功能成为分块传输编码.

### 3.3 发送多种数据的多部份对象集合

我们可以发送多种类型的文件是因为 HTTP 中采用了 MIME 机制,它允许邮件处理文本,图片,视频等多个不同类型的数据.在 MIME 扩展中会使用一种称为多部分对象集合的方法,来容纳多份不同类型的数据.

多部份对象集合包含的对象如下:

- multipart/form-data

在 Web 表单上传时使用

- multipart/byteranges

状态码 206(Partial Content, 部分内容), 响应报文包含多个范围的内容时使用.

- multipart/byteranges

传输范围指定的数据

### 3.5 获取部分内容的范围请求

指定哪个范围发送的请求叫做范围请求,利用这个特性我们可以实现在下载文件的过程中从下载中断处恢复下载.(在 Content-Range 字段里指定下载的字节范围.),如果服务器无法响应,则返回状态码 200 和完整的实体内容.

### 3.6 内容协商返回最合适的内容

内容协商机制是指客户端和服务器就响应的资源内容进行交涉,然后提供给客户端最合适的资源,内容协商会以响应资源的语言,字符集,编码方式等作为判断的基准.

**内容协商技术**

- 服务器驱动协商

由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。

- 客户端驱动协商

由客户端进行内容协商的方式,例如按照屏幕尺寸或者浏览器版本自动展示匹配的界面或者设置.

- 透明协商

是服务端驱动和客户端驱动的结合体,是由服务器端和客户端各自进行内容协商的一种方法.

## 第 4 章 返回结果的 HTTP 状态

### 4.1 状态码告知从服务器返回的请求结果

状态码的职责是当客户端向服务器发送请求时,描述返回的请求结果.借助状态码,用户可以知道服务器端是正常处理了请求,还是出现了错误.

### 4.2 2XX 成功

- 200

表示从客户端发来的请求在服务器端被正常处理了

- 204

表示服务器接收的请求已成功处理,但是返回的响应报文中不包含实体的主体部分.(OPTIONS 预请求的状态码就是 204,https 协议的资源请求会先发一个 OPTIONS 预请求)

- 206

表示客户端进行了范围请求,响应报文中包含由 Content-Range 指定范围的实体内容.

### 4.3 3XX 重定向

- 301

永久重定向, 表示请求的资源已经被分配到了新的 URI,以后应使用资源现在所指的 URI.

- 302

临时重定向,表示请求的资源已被分配了新的 URI,希望用户(本次)使用新的 URI 访问.

- 303

表示请求的资源存在着另一个 URI,应使用 GET 方法定向获取请求的资源.

303 状态码和 302 状态码有着相同的功能,但 303 状态码明确表示客户端应当采用 GET 方法获取资源,这点与 302 状态码有区别.

> 当 301,302,303 响应状态码返回时,几乎所有的浏览器都会把 POST 改成 GET,并删除请求报文内的主体,之后请求会自动再次发送.

- 304

表示客户端发送附带条件的请求(If-Match, If-None-Match, If-Range, If-modified-Since, If-Unmodified-Since 中任一首部),服务器允许请求访问资源,但未满足条件的情况,304 返回时,不包含任何响应主体部分.(常见于客户端请求资源是否过期,若资源未过期,则返回 304,告诉浏览器从缓存里读取资源.),我的理解 304 也是重定向,只是定向的资源地址是浏览器缓存.

- 307

临时重定向,和 302 有着相同的含义,但 302 标准禁止 POST 变换成 GET,实际使用浏览器没有遵守,307 会遵照浏览器标准,不会从 POST 变成 GET,但对于处理响应时的行为,每种浏览器会出现不同的情况.

### 4.4 4XX(客户端错误)

- 400

表示请求报文中存在语法错误

- 401

表示发送的请求需要有通过 HTTP 认证的认证信息.另外若之前已经进行过一次请求,则表示用户认证失败.

- 403

表示请求资源的访问被服务器拒绝了(用户的 IP 地址被加入了服务器的访问黑名单的时候会出现这种情况)

- 404

表示服务器上无法找到请求的资源,也可以作为服务器拒绝请求的返回

### 4.5 5XX 服务器错误

- 500

表示服务器在执行请求时发生了错误,也可能是 Web 应用中存在 bug 或某些临时故障

- 503

表示服务器暂时处于超负载或正在进行停机维护,现在无法处理请求.如果事先得知解除以上状况需要的时间,最好写入 RetryAfter 首部字段再返回给客户端.

## 第 5 章 与 HTTP 协作的 Web 服务器

### 5.1 用单台虚拟主机实现多个域名

可以利用虚拟主机(Virtual Host,又称虚拟服务器)来实现一台服务器为多位客户服务,如果一台服务器托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名,在相同的 IP 地址下,由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站,因此在发送 HTTP 请求时,必须在 Host 首部内完整指定主机名或域名的 URI.

### 5.2 通信数据转发程序: 代理,网关,隧道

HTTP 通信时,除客户端和服务器意外,还有一些用于通信数据转发的应用程序,例如代理,网关和隧道,它们可以配合服务器工作.

- 代理

代理是一种中间转发的应用程序,它扮演"中间人"的角色,接收客户端发送的请求并转发给服务器,同时也接收服务器返回的响应转发给客户端.

使用代理服务器的理由是: 利用缓存技术减少网络带宽的流量,组织内部针对特定网站的访问控制,以获取日志为主要目的,等等

代理通常分为两类: 缓存地阿里和透明代理,缓存代理会预先将资源的副本缓存在代理服务器上,当接收到资源请求时,就将之前缓存的资源返回.透明代理是指对保温不做任何加工的代理.对报文进行加工的代理称为非透明代理.

**缓存代理**

- 网关

网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,他就像自己拥有资源的源服务器一样对请求进行处理,有时客户端不会察觉,自己的通信目标是一个网关.

网关的工作机制和代理十分相似,网关能使通信线路上的服务器提供非 HTTP 协议服务,利用网关能提高通信的安全性,因为可以在客户端与网关之间的通信线路上加密以确保连接的安全.

- 隧道

隧道是在相隔很远的客户端和服务器之间进行中转,并保持双方通信连接的应用程序.隧道可按要求建立起一条与其他服务器的通信线路,使用 SSL 等加密手段进行通信,隧道的目的是确保客户端与服务器进行安全的通信.

### 5.3 保存资源的缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本.

缓存的资源拥有有效期,资源被请求的时候会进行资源有效期的校验,若资源已过期,则会从源服务器请求最新的资源.

## 第 6 章 HTTP 首部

### 6.1 HTTP 报文首部

HTTP 协议的请求和响应报文中必定包含 HTTP 首部,首部内容为客户端和服务器分别处理请求和响应提供所需要的信息.

HTTP 请求报文由方法, URI,HTTP 版本,HTTP 首部字段等部分构成.

HTTP 响应报文由 HTTP 版本,状态码,HTTP 首部字段 3 部分构成.

### 6.2 HTTP 首部字段

HTTP 首部字段给浏览器和服务器提供报文主体大小,所使用的语言,认证信息等内容.

HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔

字段值对应单个 HTTP 首部字段可以有多个值

**4 中 HTTP 首部字段类型**

- 通用首部字段（General Header Fields）

请求报文和响应报文两方都会使用的首部

- 请求首部字段（Request Header Fields）

从客户端向服务器端发送请求报文时使用的首部, 如客户端信息,相应内容相关优先级等.

- 响应首部字段（Response Header Fields）

从服务器端向客户端返回响应报文时使用的首部。

- 实体首部字段（Entity Header Fields）

针对请求报文和响应报文的实体部分使用的首部。

**通用首部字段**

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

**请求首部字段**

| 首部字段名          | 说明                                              |
| ------------------- | ------------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                          |
| Accept-Charset      | 优先的字符集                                      |
| Accept-Encoding     | 优先的内容编码                                    |
| Accept-Language     | 优先的语言（自然语言）                            |
| Authorization       | Web 认证信息                                      |
| Expect              | 期待服务器的特定行为                              |
| From                | 用户的电子邮箱地址                                |
| Host                | 请求资源所在服务器                                |
| If-Match            | 比较实体标记（ETag）                              |
| If-Modified-Since   | 比较资源的更新时间                                |
| If-None-Match       | 比较尸体标记(与 If-Match 相反)                    |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求              |
| If-Unmodified-Since | 比较资源的未更新时间（与 If-Modified-Since 相反） |
| Max-Forwards        | 最大传输逐跳数                                    |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                    |
| Range               | 实体的字节范围请求                                |
| Referer             | 对请求中 URI 的原始获取方                         |
| TE                  | 传输编码的优先级                                  |
| User-Agent          | HTTP 客户端程序的信息                             |

**响应首部字段**

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

**实体首部字段**

| 首部字段名       | 说明                       |
| ---------------- | -------------------------- |
| Allow            | 资源可支持的 HTTP 方法     |
| Content-Encoding | 实体主体适用的编码方式     |
| Content-Language | 实体主体的自然语言         |
| Conent-Length    | 实体主体的大小(单位: 字节) |
| Conent-Location  | 替代对应资源的 URI         |
| Content-MD5      | 实体主体的报文摘要         |
| Content-Range    | 实体主体的位置范围         |
| Content-Type     | 实体主体的媒体类型         |
| Expires          | 实体主体的过期时间         |
| Last-Modified    | 资源的最后修改日期时间     |

**非 HTTP/1.1 首部字段**

常用的首部字段,还有 Cookie、Set-Cookie 和 Content-Disposition
等在其他 RFC 中定义的首部字段

1. Cache-Control

该首部字段主要用于控制浏览器的缓存行为.常用的字段值如下:

- public: 表示代理服务器和客户端均可缓存

- private: 值对特定用户提供缓存服务,代理服务器则不会缓存

- no-cache: 请求资源时,先去源服务器询问资源是否新鲜,从而觉得从缓存读取资源还是从服务器获取资源

- no-store: 不进行缓存

- max-age: 定义资源被保存为缓存的最长时间
- min-fresh: 要求缓存服务器返回至少还未过指定时间的缓存资源
- max-stale: 只要资源仍处于 max-stale 指定的时间内,即使资源过期,仍旧会被客户端接收.

2. Connection

- 控制不再转发给代理的首部字段 `Connect: 不再转发的首部字段名`
- 管理持久连接 `Connect: keep-alive/close; 断开和维持持久连接`


## CDN

CDN（content delivery network，即内容分发网络）。CDN是建立在现有网络基础之上的虚拟智能网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡，内容分发，调度等功能莫亏啊，使用户就近获取所需内容，降低网络拥塞，提高用户访问的响应速度和命中率。CDN的关键技术有内容存储和分发技术。

CDN网络中包含的功能实体包含内容缓存设备，内容交换机，内容路由器，cdn内容管理系统组成。

内容缓存为cdn网络节点，位于用户接入点，是面向最终用户的内容提供设备，可缓存静态web内容和流媒体内容，实现内容的边缘传播和存储，以便用户的就近访问。

内容交换机处于用户接入点集中点，可以均衡单点多个内容缓存设备的负载，并对内容进行缓存负载平衡及访问控制。

内容路由器复杂将用户的请求调度到适当的设备上，内容路由通常通过负载均衡系统来实现，动态均衡各个站点的载荷分配，为用户的请求选择最佳的访问站点，同时提高网站的可用性，内容路由器可根据多种因素制定路由，包括站点与用户的临近度，内容的可用性，网络负载，设备情况等。负载均衡系统是整个cdn的核心。负载均衡的准确性和效率直接决定了整个cdn的效率和性能。

## HTTPS
HTTPS指的是超文本传输安全协议，HTTPS是基于HTTP协议的，不过它使用TLS/SSL来做数据加密。使用TLS/SSL协议，所有的信息加密的，第三方很难窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。

### TSL握手过程
1. 第一步：客户端向服务器发送请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 第二步：服务器接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 第三步：客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且会提供一个前面所有内容的hash值，用来供服务器检验。
4. 第四步：服务端使用自己的私钥，来解密客户端发过来的随机数。并提供前面所有内容的hash值来供客户端检验。
5. 第五步：客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都是用这个秘钥来加密信息。

### 实现原理

TSL的握手过程主要用到了三个方法来保证传输的安全。

- 对称加密：对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密存在一个问题，就是如何保证私钥传输的安全性，因为私钥需要通过网络传输，一旦私钥被其他人获取到，那么整个加密过程就毫无作用了。

- 非对称加密：非对称加密的方法是，我们拥有两个秘钥，一个公钥、一个私钥。公钥匙公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，如果每次通信都使用非对称加密的方式，会造成等待时间过长的问题。

因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的缺点是无法保证秘钥的安全传输，因此我们可以用非对称加密的方式来传输对称加密的秘钥，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。

但是现在的方法也不一定是安全的，因为我们没有办法确定得到的公钥/私钥一定是安全的公钥/私钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密发送后的信息，就可以被他自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取。

为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种hash算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心（简称CA）用它的私钥对信息摘要加密，形成签名。最后将原始的信息和签名合在一起，生成数字证书。当接收方收到数字证书的时候，先根据原始的信息使用同样的hash算法生成一个摘要，然后使用公证处公证的公钥对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能确认收到的信息是否被篡改。这个方法最重要的是认证中心的可靠性，一般浏览器会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。

### ssl连接断开后如何恢复

一共有两种方法来恢复断开后的ssl连接，一种是session id，一种是session ticket。

- 使用session ID的方式：

每一次的会话都会有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务端有这个编号的记录，双方就可以继续使用以前的秘钥，不用重新生成。目前所有的浏览器都支持这一种方法。但是这个方法有一个缺点，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。

- session ticket 的方式：

session ticket是在上一次对话中发送给客户端的，这个ticket是加密的，只有服务端能够解密，里面包含了本次会话的信息，比如对话秘钥和解密方法等，这样无论请求被转发到哪个服务器，服务器将ticket解密以后，就能获取上次对话的信息，就不用重新生成对话秘钥了。

