# 深入学习编译原理

1. 什么是编译?

编译是一种转换技术,从一门编程语言到另一门编程语言,从高级语言转换成低级语言,或者从高级语言到高级语言,这样的转换技术.

2. 高级语言与低级语言

低级语言是与机器有关的,涉及到寄存器,cpu指令等,低的意思可以理解为底层,描述具体在机器上的执行过程,比如机器语言,汇编语言,字节码等.

高级语言,则没有这些具体执行的东西,主要用来表达和处理逻辑,而且提供了条件,循环,函数,面向对象等特性来组织逻辑,又不影响具体执行.直接写汇编,可以写出效率更高的代码.

但是如果高级语言通过编译转换为低级语言,就很难保证代码的执行效率了,需要各种编译优化,这是编译领域的难点.

3. 编译的过程是怎样的的?

这个首先要了解编译双方的语言特性.比如高级语言到高级语言,要转换的是字符串,按照一定格式组织的,这些格式分别叫做词法,语法,整体叫文法,那要转换的目标呢?我们需要了解目标的格式,       

或者指令含义,然后进行`语义等价`的转换,即保证翻译的准确性,不能丢失或添加语义,要保持前后一致.

**转换过程**:

* parse
 要转换成计算机理解的东西,要先根据我们规定的词法,语法格式进行分词处理,再构造语法书.要按照一定的数据结构把源码字符串解析后的结果组织起来,计算机就能处理了.

分词(分出的词要遵循词法或者语法规则)是按照状态机来分的(`有限状态机DFA`),词法描述的是最小的单词的格式,比如标识符不能以数字开头,然后后面加字母数字下划线等.

分词把单词拆分成一个个不能再拆的单词,也叫token,字符串的状态处理和流转就是状态自动机,每个识别了的token组成一个token数组.

**组装成抽象语法树**

`Abtract Syntaxt Tree`,大多数的高级语言都存在嵌套的书写,所以需要将我们词法分析得到的一个单词按照某种语言的语法规则组装成抽象语法树.

`ll`: 先根据一两个单词判断是那种语法,然后再按照语法规则进行组装.

`lr`: 先组装一些单词,组装完了看符合什么语法格式

把树形的ast转换成另一个ast,然后在打印成目标代码的字符串,这是转译器(babel);

把ast解释执行或者转成线性的中间代码再执行,这是解释器(V8引擎).

把ast转成线性中间代码,然后生成会变代码,之后做汇编和连接,生成机器码,这是编译器.

4. 编译器是怎么处理AST的?

要先把ast转成线性IR,再生成汇编,字节码等.但是ast转中间代码的过程中,还需要做"语义分析".

**语义分析** 要检查出语义的错误,比如类型是否匹配,引用的变量是否存在,break是否在while中等,主要做 `作用域分析`. `引用消解`, `类型推导和检查`, `正确性检查`等.

语义分析之后,先翻译成线性IR,然后对线性IR进行优化,需要优化就是因为自动生成的代码难免会有很多冗余,需要把各种没必要的处理去掉(死代码,公共子表达式,常量传播).

**线性IR分析**:线性IR的分析要建立流图,控制流图,由控制函数控制程序跳转,把顺序执行的代码和跳转的代码连接起来,顺序执行的代码看做一个基本块,之后根据这个流图做数据流分析

也就是一个变量流经了哪些代码,然后做各种优化.

优化之后的线性IR可以生成汇编代码,然后通过汇编器转成机器码,再链接一些标准库,可以静态链接成一个可执行文件.



5. babel的转义过程

**js是解释型语言.taro是基于babel封装的.**

 `parse -> transform -> generate`
 
 parse: 词法分析,语法分析,语义分析 ,生成抽象语法树
 
 transform: 对ast无用的节点删除,相应的节点加标记, 做一些节点的增删改操作.
 
 generate: 将处理后的ast转成可以被浏览器正确执行的js代码.
 

6. 解释器不生成机器代码,如何执行?

解释器和编译器的分别是是否生成代码,解释器不生成机器代码,编译器生成机器代码. 提前编译成机器代码叫做AOT编译器,运行时编译成机器代码的叫做JIT编译器.

解释器是一门高级语言来解释另一门高级语言,比如C++,一般都用c++来写解释器,因为可以做内存管理.用c++来写js解释器,像V8,spdermonkey等都是,我们在有了ast并且做完语义分析之后

可以遍历ast,然后用c++来执行不同的节点了,这种叫做 `tree walker`解释器,直接解释执行ast,v8引擎在17年之前都是这么干的.但是17年之火引入了字节码,因为字节码可以缓存,这样

下次再直接执行字节码就不需要parse了.字节码是种线性结构,也要做到ast 到线性 ir 的转换,之后再vm上执行字节码.

`ignation` 解释器就是把parse出的ast转成字节码,然后解释执行字节码,热度达到阈值之后会交给 turbofan 编译为汇编代码之后生成机器代码,来加速.gc是独立的做内存管理的.

`turbofan`是涡轮增压器,这个名字就能体现JIT的意义.但JIT提升了执行速度,也有缺点,比如会使得js引擎体积更大,占用内存更大,所以轻量级的js引擎不会包含jit,这就是运行速度和

包大小,内存之间的权衡.架构设计及也经常要做这种两边都可以,但是要做选择的`trade off`,我们叫做方案勾兑.例如 rn的js引擎hermes就改成直接执行字节码了,在编译期间把js代码

编译成字节码,然后直接执行字节码,这就是在跨端领域js引擎的 `trade off`.


7. 前端领域哪些地方用到编译知识

`工程化领域各种转译器`: babel, typescript, eslint, terser, prettier, postcss, posthtml, taro, vue template compiler等

`js引擎`: v8, javascriptcore, quickjs, hermes等

`wasm`: llvm可以生成wasm字节码,所以c++,rust等可以转为llvm, ir的语言可以做wasm开发

`ide 的lsp`: 编程语言的语法高亮,智能提示,错误检查等通过 language service protocol 协议来通信,而lsp服务端主要基于parser对正在编辑的文本做分析.

8. 编译原理 -> 语言

编程语言主要还是设计,实现的话首先实现parser和语义分析,后面分为两条路,一种是解释执行的解释器配合JIT编译器的路,一种是变异成汇编代码.然后生成机器码再链接成可执行文件的
编译器的路.

一门语言是编译型还是解释型主要是主流的方式是编译还是解释来决定的.

编程语言可以分为GPL和DSL两种.

GPL是通用编程语言，它是图灵完备的，也就是能够描述任何可计算问题，像c++、java、python、go、rust等这些语言都是图灵完备的，所以一门语言能实现的另一门语言都能实现，

只不过实现难度不同

DSL 不是图灵完备的，却换取了某领域的更强的表达能力，比如html、css、正则表达式，jq的选择器语法等等，比较像一种伪代码，特定领域的表达能力很强，

但是却不是图灵完备的不能描述所有可计算问题。

