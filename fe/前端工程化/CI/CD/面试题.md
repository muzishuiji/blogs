1. 前端部署工程或者发布新版本后，如何通知用户刷新页面？

核心原则：既要保证版本一致性，又要尽可能减少对用户的干扰

重要更新强提示，常规更新弱提示
    方案一：轮询

    方案二：websocket

    方案三：service worker

    服务器监测到文件有更新，就会触发service worker的updatefound事件，监听worker状态变化，install则下载好，就可以弹窗提示用户了

2. CI/CD 部署平台是如何保证新版本发布后，用户侧可以按灰度拉取到目标资源的？

灰度发布（也称为金丝雀发布）是一种降低发布风险的策略，通过逐步将新版本推送给部分用户来实现。以下是主要的实现方案：

1. 资源版本控制
   - 构建时为静态资源生成唯一的版本号或 hash 值（如 webpack 的 contenthash）
   - CDN 上同时存在新旧两个版本的资源
   - HTML 入口文件通过版本策略决定加载哪个版本的资源

2. 流量控制策略
   a) 按用户特征灰度
      - 根据用户 ID、地域、设备类型等特征决定是否下发新版本
      - 通过配置中心动态调整灰度规则和比例
   
   b) 按比例灰度
      - 使用一致性哈希算法确保同一用户始终访问相同版本
      - 通过调整哈希范围逐步扩大新版本覆盖比例

3. 技术实现方案
   a) DNS 层面
      - 配置多个 A 记录，不同记录指向不同版本的服务器
      - 通过调整权重控制流量分配

   b) 负载均衡层面
      - Nginx 配置不同的 upstream 对应不同版本
      - 通过 location 规则和随机数实现按比例分配
      ```nginx
      # Nginx 配置示例
      location / {
          set $upstream '';
          if ($random_number < 0.2) {  # 20% 流量进入新版本
              set $upstream new_version;
          }
          proxy_pass http://$upstream;
      }
      ```

   c) 应用层面
      - 使用 Cookie 或 LocalStorage 记录用户所属版本
      - 前端路由或后端接口根据标记返回对应版本内容

4. 监控和回滚机制
   - 实时监控新版本的性能指标、错误率等
   - 设置自动回滚阈值，超过阈值自动降级到稳定版本
   - 保留快速回滚通道，确保出现问题时可以迅速切回旧版本

5. 最佳实践
   - 先灰度非核心地区或非重要用户群体
   - 渐进式扩大灰度比例（如 5% -> 20% -> 50% -> 100%）
   - 保持完善的监控和报警机制
   - 制定清晰的灰度发布流程和回滚策略

通过以上措施的组合使用，可以实现安全可控的灰度发布，既保证了系统稳定性，又能快速验证新版本的效果。

// 一致性哈希算法示例代码：
```javascript
class ConsistentHash {
    constructor(replicas = 100) {
        this.replicas = replicas;        // 虚拟节点数量
        this.ring = new Map();           // 哈希环
        this.sortedKeys = [];            // 已排序的哈希值
        this.versions = new Set();       // 可用版本集合
    }

    // 添加版本节点
    addVersion(version) {
        this.versions.add(version);
        
        // 为每个版本创建多个虚拟节点
        for (let i = 0; i < this.replicas; i++) {
            const key = this.hash(`${version}-${i}`);
            this.ring.set(key, version);
        }
        
        // 重新排序哈希值
        this.sortedKeys = Array.from(this.ring.keys()).sort((a, b) => a - b);
    }

    // 移除版本节点
    removeVersion(version) {
        this.versions.delete(version);
        
        for (let i = 0; i < this.replicas; i++) {
            const key = this.hash(`${version}-${i}`);
            this.ring.delete(key);
        }
        
        this.sortedKeys = Array.from(this.ring.keys()).sort((a, b) => a - b);
    }

    // 获取用户应该使用的版本
    getVersion(userId) {
        if (this.ring.size === 0) return null;

        const hash = this.hash(userId.toString());
        
        // 在哈希环上顺时针查找第一个大于等于 hash 的节点
        const index = this.sortedKeys.findIndex(key => key >= hash);
        const nearestKey = index === -1 ? this.sortedKeys[0] : this.sortedKeys[index];
        
        return this.ring.get(nearestKey);
    }

    // 哈希函数 (使用简单的 djb2 算法)
    hash(str) {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) + hash) + str.charCodeAt(i);
        }
        return hash >>> 0; // 转换为无符号整数
    }
}

// 使用示例：
const grayscale = new ConsistentHash();

// 添加版本
grayscale.addVersion('v1.0.0'); // 稳定版本
grayscale.addVersion('v1.1.0'); // 新版本

// 模拟用户访问
function getUserVersion(userId) {
    return grayscale.getVersion(userId);
}

// 测试不同用户的版本分配
console.log(getUserVersion('user123')); // 可能返回 'v1.0.0'
console.log(getUserVersion('user456')); // 可能返回 'v1.1.0'
console.log(getUserVersion('user123')); // 同一用户始终返回相同版本

// 灰度发布场景示例
function isUserInNewVersion(userId, rolloutPercentage) {
    const hash = grayscale.hash(userId.toString());
    const normalizedHash = (hash % 100) / 100; // 归一化到 0-1 范围
    return normalizedHash < rolloutPercentage;
}

// 使用示例
const userId = 'user123';
const rolloutPercentage = 0.2; // 20% 灰度比例
console.log(`用户 ${userId} ${isUserInNewVersion(userId, rolloutPercentage) ? '可以' : '不可以'}访问新版本`);
```

上述代码实现了一个基本的一致性哈希算法，主要特点：

1. 虚拟节点：通过增加虚拟节点（replicas）来使哈希分布更均匀
2. 版本一致性：同一用户的哈希值始终映射到相同的版本
3. 平滑迁移：添加或删除版本时，只影响哈希环上相邻节点之间的用户
4. 灰度控制：可以通过调整版本节点数量来控制不同版本的流量比例

使用场景：

1. 前端路由级别：
```javascript
// 在路由守卫中使用
router.beforeEach((to, from, next) => {
    const userId = getUserId(); // 获取当前用户ID
    const version = grayscale.getVersion(userId);
    
    if (version === 'v1.1.0') {
        // 加载新版本的资源
        loadNewVersionAssets();
    }
    next();
});
```

2. 资源加载级别：
```javascript
// 在 HTML 中使用
const userId = getUserId();
const version = grayscale.getVersion(userId);
const scriptUrl = version === 'v1.1.0' 
    ? 'https://cdn.example.com/v1.1.0/app.js'
    : 'https://cdn.example.com/v1.0.0/app.js';

// 动态加载对应版本的资源
const script = document.createElement('script');
script.src = scriptUrl;
document.head.appendChild(script);
```
