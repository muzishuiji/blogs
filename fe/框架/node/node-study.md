# Node.js 开发实战

## Node 的基本认知

1. 使用 node.js 开发遇到的一些问题

- 程序运行不稳定

- 程序运行效率低

2. Node 的一些使用场景

- Web 服务

- 开发工作流

- 客户端应用

BFF 为前端业务提供数据服务的后端程序

3. 什么是 Node.js

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境,

Node.js 使用了一个事件驱动,非阻塞式 I/O 的模型.

4. 为什么要做服务端渲染?

- 要做搜索引擎优化和首屏速度优化

- 服务端渲染+前后端同构

5. 技术预研

BFF(backend for frontend)

## Node.js 内置模块

1. EventEmitter

观察者模式:

- addEventListener
- removeEventListener

使用场景: 1. 不确定被通知者是谁; 2. 需要确定有观察者监听;

2. nodejs 的非阻塞 I/O

- I/O 即 input/output,一个系统的输入和输出
- 阻塞 I/O 和非阻塞 I/O 的区别就在于系统接收输入再到输出期间,能不能接收其他输入
  理解非阻塞 I/O 的要点在于:
- 确定一个进行 input/output 的系统
- 思考在 I/O 过程中,能不能进行其他 I/O
  nodejs 通过非阻塞 I/O 的模式实现各个线程的有序调用和处理.

## Node.js 异步编程

1. 回调函数格式规范

- error-first callback
- Node-style callback

2. 第一个参数是 error,后面参数才是结果

3. 在 Nodejs 中抛出全局的错误是一个很严重的事情,会导致 nodejs 程序的崩溃.

4. Promise

- 当前事件循环得不到的结果,但未来的事件循环会给到你结果
- 是一个状态机

  - pending
  - fulfilled/resolves
  - rejected

- .then 和.catch

resolved 状态的 Promise 会调用后面的第一个.then
rejected 状态的 Promise 会调用后面的第一个.catch
任何一个 rejected 状态且后面没有.catch 的 promise,都会造成浏览器/node 环境的全局错误

- 执行 then 和 catch 会返回一个新的 Promise,该 promise 最终的状态根据 then 和 catch 的回调函数的执行结果决定.
  - 如果回调函数最终是 throw,该 promise 是 rejected 状态
  - 如果回调函数最终是 return,该 promise 是 resolved 状态
  - 但如果回调函数最终 return 了一个 promise,该 Promise 会和回调函数 return 的 Promise 状态保持一致.

5. async/await

async function 是 generator 的语法糖,它是异步的一个很好的解决方案,用同步的方式编写异步.

- await 关键字可以暂停 async/await 的执行
- await 关键字可以以同步的写法获取 promise 的执行结果
- try-catch 可以获取 await 所得到的错误,是捕捉不到 promise 的错误

6. HTTP

- HTTP 服务要做什么事情
  - 解析进来的 HTTP 请求报文
  - 返回对应的 HTTP 请求报文

## express

1. 利用 express 的中间件的逻辑可以将不同的代码逻辑分割在不同的函数或者不同的逻辑中,然后通过 next()来控制这些逻辑的有序执行.
2. 中间件的执行就像洋葱一样,从最外层传到最里层,然后在一层层出来,可以再进入的时候做一些处理,然后在出来的时候最汇总处理.
3. express 的洋葱模型对于异步中间件的支持不完善,于是出现了更完善的处理中间件的插件 koa.

## koa

1. koa 函数能够通过 await 来控制异步中间件的执行,可以将异步中间件定义成 async 函数,然后通过 await 来控制执行.
2. koa 设计的理念就是微内核,本身不带有路由等功能,这些功能都是通过在 koa-router 等第三方模块实现,然后以插件的形式插入到 koa 中.精简内核,所有额外的功能都移到中间件里实现
3. express 门槛更低,koa 更强大优雅.

### koa中间件原理

koa通过核心方法use来注册中间件，然后通过一个compose函数来组合中间件，使用next来控制中间件的执行。

即koa在使用use方法解析中间件的时候遇到next会暂停当前程序，进入下一个中间件，处理完之后再回过头来继续处理，

## RPC 调用

1. Remote Procedure Call(远程过程调用)
2. 和 Ajax 有什么相同点?

- 都是两个计算机之间的网络通信
- 都需要双方约定一个数据格式

3. 和 ajax 有什么不同点?

- 不一定使用 DNS 作为寻址服务
- 应用层协议一般不使用 HTTP
- 基于 TCP 或者 UDP 协议

4. RPC 调用

- 使用特定服务寻址
- tcp 通信方式(单工通信,半双工通信和全双工通信)
- 二进制协议(更小的数据包体积,更快的编解码速率)

## Buffer

1. Buffer 模块编解码数据包
2. 多个 buffer 包同时发送过去的过程中会发生粘包的情况,这是 TCP 的优化策略,会将同时发送的数据包拼接在一起发送给服务器端,数据的发送方和接收方都会对数据做一个标识,以便多个数据包的数据的匹配.

3. 推荐使用 ES6 的模板字符串来实现模板引擎.

## API 服务

### Restful

1. restful 的特点

- 简单易懂
- 可以快速搭建
- 在数据的聚合方面有很大的劣势

### GraphQL

1. GraphQL 的的特点
   专注数据聚合,前端需要什么就返回什么.
   让前端有"自定义查询"数据的能力

## 性能优化

### 压力测试

1. 压力测试的工具

- ab
- webbench

2. QPS(Request per second): 服务器每秒钟可承载的请求数.
3. 吞吐量
4. 使用 linux 的相关命令找到性能瓶颈所在地:

- top: 可以查看服务器的 cpu 和内存你的占用率
- iostat: 检测 io 设备的带宽,硬盘等的带宽.

2. Nodejs 的自带的新能分析工具 profile
3. 在 chrome 的 inspect 网页里可以调试 node 的代码

### 性能优化的准则

1. 减少不必要的计算
2. 空间换时间,已计算出的结果缓存起来
3. 提前计算,把计算从服务阶段移动到启动阶段
4. 减少内存使用,也是提高性能优化的手段(使用合理的内存分配策略: '池)

5. node 中有一个模块 bindings 可以帮助我们很快的定位到相关文件的所在路径
   我们就不需要定义完整的路径,是需要传入文件名,该模块就可以为我们定义找到对应的文件.
6. 在 Node 中使用 c++插件
   我们可以将复杂耗时的计算交给 c++插件来运行,以此达到性能优化的目的,但是
   此过程会发生变量转换也是比较耗时的,具体是否会对性能有足够的提升还要根据具体的情况来看.

7. Nodejs 进程与线程
Node.js中的进程Process是一个全局对象，无需require直接使用，给我们提供了当前进程中的相关信息。Node.js中进程可以使用child_process模块创建。

关系：
- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的是主线程）；
- 同一进程的所有线程共享该进程的所有资源；
- 进程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步；
- 处理机分给线程，即真正在处理机上运行的是线程；
- 线程是指进程内的一个执行单元，也是进程内的可调度实体；
区别：
- 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
- 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；


8. Nodejs 的事件循环

- 主线程运行 V8 和 JavaScript
- 多个子线程通过事件循环被调度
  通过这些进程的调度我们可以将费时的任务分配给多个线程进行处理,然后统一汇总,从而提供更好的性能.

** 子进程分发: **

通过 cluster 模块,可以创建多个子进程,将主进程的任务做分发,从而有效提升服务响应和任务处理的能力.充分利用服务器的多个 cpu 来处理请求.
子进程和父进程监听同一个端口不会报错,因为子进程是获取一个已经被父进程监听的 server,而不是有创建一个监听同样端口的 server.

8. nodejs 的进程守护与管理

一个 js 的报错就会导致整个进程的中止,所以在开发过程中需要完善的错误捕获的机制,编写完整的错误捕获的代码,在捕获到错误之后上报错误,然后也要终止进程,如果不终止进程,很可能会导致进程虽然在开启状态,但是处于一个不可服务的状态,所以要及时终止进程.

一个进程守护策略是在监听到进程退出之后,设置一个定时器一段时间间隔之后重新启动进程.同时需要监听内存是否泄露,在监听到内存泄漏之后退出进程.同时可以和子进程保持一个心跳操作,间隔一段时间给子进程发消息,如果子进程那里没有反应则说明进程处于假死状态或子进程退出,这个时候需要做相应的上报处理(杀掉对应的子进程)等.

### 从架构层面优化 Nodejs 程序

1. 动静分离

- 静态内容
  概念: 基本不会变动,也不会因为请求参数不同而变化
  处理策略: CDN 分发,HTTP 缓存等

- 动态内容
  概念: 因为请求参数而变动,而变动的数量几乎不可枚举
  处理策略: 用大量的源站机器承载,结合反向代理进行负载均衡

利用 nginx 输出静态文件的响应速度比使用 node 返回静态文件的响应速度快很多

2. nginx 负载均衡

在 nginx 的配置文件中可以使用 upstream 来配置上游集群:

    upstream node.com{
      server 127.0.0.1:3000;
      server 127.0.0.1:3002;
    }
    // 然后在反向代理部分设置代理到对应的服务器集群下,即可实现简单的负载均衡
    // nginx会帮我们转发到对应的集群,并均衡地分配给集群里对应的服务器,从而让请求方获得更快的响应速度
    location ! /node/(\d*) {
      proxy_pass http://node.comdetail?columnid=$1
    }

redis 使用机器的内存做缓存存储,因此读写速度会很快,但是应该不适合存储大量的数据

## 设计模式

设计模式其实就是设计可重用的应用程序的准则.

1. 观察者模式

2. 外观模式

暴露出来一个简单易用的方法,有一个优雅的外观,将兼容性处理等放在函数内部,使用者不必去管理.

3. 单一职责原则
   每个模块都有明确的功能.
4. 开闭原则

对扩展开放,对修改关闭.

## serverless

1. 特点

- 云函数
  不用再因为运维,架构的事情操心

  - 缩短业务上线周期
  - 减少出错的概率
  - 业务开发上手难度更低

- 渐进式
  上手容易,优化需要深入了解
- serverless, 屏蔽了服务器细节

2. 好的框架

好的框架就是把复杂的,通用的东西下沉(less 化) -> 实现渐进式

3. 我们要做的事情

- nodejs BFF 层应用到大部分的业务

  - 快速扩展 Node.js 业务页面
  - 新人能不理会底层细节快速上手
