# typescript 实战学习笔记

## 01 重塑“类型思维”

1. 什么是 typescript?

官方定义: 有类型系统的 JavaScript 的超集,可以编译成 JavaScript;

2. typescript 的特性:

- 类型检查

typescript 会在编译代码时,进行严格的静态类型检查,可以使你在编码阶段发现代码的隐藏的语法问题;

- 语言扩展

typescript 会包含来自 ECMAScript6 和未来提案中的新特性(装饰器等),也会从其它语言借鉴某些特性,如接口和抽象类等.

- 工具属性

typescript 可以编译成标准的 JavaScript,就可以在任何浏览器和操作系统上运行,无需任何运行时的额外开销;

3. 为什么要使用 typescript?

- 充分利用工具优势

vscode 具有强大的自动补全,导航和重构功能,这使得接口定义可以直接代替文档,同时可以提高开发效率,降低维护成本;

- 重塑"类型思维",规定代码

typescript 可以帮助团队重塑"类型思维",接口提供方被迫去思考 API 的边界,使得他们从代码的编写者蜕变为代码的设计者;

## 02 强类型与弱类型

1. 静态类型语言与动态类型语言

静态类型语言: 在编译阶段确定所有变量的类型

动态类型语言: 在执行阶段确定所有变量的类型

## 04 TypeScript 基础

1. 类型注解

作用: 相当于强类型语言中的类型声明;

语法: (变量/函数): type

2. 元组

元祖,元组是一种特殊的数组,它限定了数组中元素的个数和类型,我们可以尝试给一个元组添加新的元素,但是不能进行越界访问.

3. js 中的 undefined 不是关键字或保留字,是可以作为变量名来使用的,虽然不建议这么做.
4. 枚举成员的值是只读的,定义之后就不能修改的
5. 用 const 声明的枚举就是常量枚举,当我们不需要一个对象而需要一个对象的值的时候可以使用这个;
6. 将程序中未来可能会改变的常量抽取出来定义成枚举类型,这样可以增强代码的可读性和可维护性;
7. 如果一个类的构造函数被添加了 private,则这个类既不能够被继承,也不能够实例化;

受保护成员,一个受保护成员只能在类或子类中访问,而不能在实例中访问;

如果类的 constructor 被 protected,则这个类只能够作为基类,被子类访问,不能够在实例中访问;

如果实例属性被声明为只读属性(readonly),则不能够被修改;

static 修饰符,定义类的静态成员,类的静态成员只能通过类名来访问, 不能通过实例来访问,但是可以被子类继承,从而可以被子类访问;

8. 抽象类(abstract)

只能被继承,不能够被实例化的类,也可以理解为基类;在抽象类中,不指定方法的具体实现,就构成了抽象方法,抽象方法的好处是你明确知道子类会有具体的实现,在父类中就不需要做具体的实现了,抽象类的好处就是抽离事物的共性,这样更有利于代码的复用和扩展,另外抽象类也可以实现多态,就是在抽象类中定义抽象方法,然后不同的子类有自己的实现,程序运行时,根据不同的对象实现不同的操作;

9. 在类中定义的方法里返回 this,也可以实现实例的链式调用;


    class WorkFlow {
        step1() {
            return this;
        }
        step2() {
            return this;
        }
    }
    new WorkFlow().step1().step2()
    // 通过在子类中返回this可以实现父类方法和子类方法的穿插式链式调用
    class Myflow extends WorkFlow {
        next() {
            return this;
        }
    }
    new Myflow().next().step2().next().step1()

10. 类和接口的关系

- 接口和类都可以实现继承
- 接口可以继承类的共有成员(public),私有成员(private)和受保护的成员(protected)
- 实现接口定义的类,只能实现共有成员

11. 泛型

不预先确定的数据类型，具体的类型在使用的时候才能确定。

使用泛型的好处:

- (1) 函数和类可以轻松的支持多种类型,增强程序的扩展性
- (2) 不必写多条函数重载,冗长的联合类型声明,增强代码可读性
- (3) 灵活控制类型之间的约束

12. TS 的类型检查机制

TypeScript 编译器在做类型检查时,所秉承的一些原则,以及表现出的一些行为.类型检查的作用: 辅助开发,提升开发效率.类型检查的内容:

- 类型推断
- 类型兼容性
- 类型保护

13. 类型推断

不需要指定变量的类型(函数的返回值类型),TypeScript 可以根据某些规则自动的为其推断出一个类型.类型推断分为以下三种:

- 基础类型推断
- 最佳通用类型推断
- 上下文类型推断

14. 当你明确知道当前正在上会用的变量的类型以及其可能发生的一些逻辑操作的时候,你可以抛开类型推断,使用类型断言,但是避免类型断言的滥用;
15. 类型兼容性
    当一个类型 Y 可以被赋值给另一个类型 X 时,我们就可以说类型 X 兼容类型 Y;

X 兼容 Y: X(目标类型) = Y(源类型)

    let s: stribf = 'a';
    s = null;  // null类型是string类型的源类型,string类型兼容null类型
    // 也可以说null是string的子类型
    // 类型兼容性的虽然存会产生一些不可靠的行为,但是增强了编码的灵活性
    // 源类型如果具有目标类型的必要属性,则可以兼容.
    // 简单来说就是成员少的兼容成员多的

16. 类型兼容规则

结构之间兼容: 成员少的兼容成员多的
函数之间兼容: 参数多的兼容参数少的

17. 类型保护

TypeScript 能够在特定的区块中保证某个变量属于某种确定的类型,可以在此区块中放心的引用此类型的属性,或者调用此类型的方法.

类型保护的四种判断机制:

- (1) instanceof
- (2) in
- (3) typeof
- (4) 使用类型保护函数判断

18. 高阶类型

- (1) 交叉类型与联合类型

交叉类型是指将多个类型合并为一个类型,那么这一个类型就会具有多个类型的特性,意为多个类型的并集

联合类型意为多个类型中选择一个类型,联合类型的对象在不确定数据类型的情况下只能访问联合类型成员中的共有属性.

我们可以使用交叉类型做对象的混入,可以使用联合类型来保持代码的不确定性,从而提高代码的灵活性;

- (2) 索引类型

  当我们从对象中获取一些属性的值的时候,我们需要对传入的属性做类型约束,这个时候就用到了索引类型,我们可以使用 keyof obj 来约定传入的属性参数是 obj 的索引.keyof T 表示 T 的所有公共属性的字面量的联合类型, 如果 T 是{a:string, b: number}, K keyof T,则 K 的值为 a | b

- (3) 映射类型

通过映射类型我们可以从一个静的类型生成一个新的类型
同态的映射类型,只会作用于基础类型的属性,而不会创建出新的属性

    // ts内置的映射类型
    interface Obj3 {
        a: string;
        b: number;
        c: boolean;
    }
    // 只读映射类型,映射出的新的类型的各个属性是只读的
    type ReadonlyObj = Readonly<Obj3>;
    // 可选映射类型,映射出的新类型的各个属性是可选的
    type PartialObj = Partial<Obj3>;
    // 子集映射类型,映射出的新类型是各个属性组成的子集
    type PickObj = Pick<Obj3, "a" | "b">;
    // 非同态类型,增加不属于Obj属性的新属性
    // 定义一个新的类型,这样新的类型的一个或多个属性是基本类型Obj3
    type RecordObj = Record<"x" | "y", Obj3>;
    // type RecordObj = {
    //   x: Obj3;
    //   y: Obj3;
    // }

- (4) 条件类型

        // T extends U ? X : Y
        type TypeName<T> = T extends string
            ? "string"
            : T extends number
            ? "number"
            : T extends boolean
            ? "boolean"
            : T extends undefined
            ? "undefined"
            : T extends Function
            ? "function"
            : "object";

条件类型可以同来为我们过滤掉一些不需要的类型;

        // Diff类型的作用就是从类型T中过滤掉可以赋值给类型U的类型
        type Diff<T, U> = T extends U ? never : T;
        type T4 = Diff<"a" | "b" | "c", "a" | "e">; // "b" | "c"
        // 从类型中出undefin和null
        type NotNull<T> = T extends undefined | null ? never : T;
        type T5 = NotNull<"a" | "b" | null>; // "a" | "b"

## 05 实战阶段

### ES6 与 Commonjs 的模块系统

### 命名空间

### 声明合并

声明合并是指编译器会把多个地方具有相同名称的声明合并为一个声明,这样可以合并散落各处的重复声明.最常见的声明合并是接口的声明合并.

接口声明合并时候的非函数成员重复生命需要保持类型相同,函数成员的重复声明则会发生重载,重复的函数成员的声明在合并时候的顺序是先声明的接口里的函数排在后面,接口内部是按照函数定义的先后顺序排序,但是有一个例外情况,就是函数参数是以字面量的形式生命的函数的顺序要排在前面.

需要注意的是相同命名空间不能导出同名内容;

命名空间在于函数声明,类声明,枚举声明进行合并的时候一定要放在对应生命的下面;

### 如何编写声明文件

### tsConfig 的配置

- files
  指定需要编译的 ts 文件
- include
  指定文件查找的目录
- exclude
  指定文件查找需要排除的文件目录

配置文件的内容是可以继承的,可以把基础的配置抽离出来.
开发中遇到报错可以去配置文件中查找相关的配置项,看看能否解决问题.

### 工程引用

可以灵活的配置输出目录,还可以使工程之间产生依赖关系,还有利于把一个大的项目拆分成小的项目,同时还可以利用增量编译提升编译速度.

1. awesome-typescript-loader

与 ts-loader 的主要区别:

- 1. 更适合与 babel 集成,使用 babel 的转义和缓存
- 2. 不需要安装额外的插件,就可以把类型检查放在独立进程中进行

2. ts vs babel

四种在 babel 编译的项目中使用的 ts 语法无法正常编译

- namespace
- 断言
- 常量枚举
- export = 默认导出

3. TSLint 迁移到 ESLint 的原因:

- 1. TSLint 的执行方式村咋一些架构问题,影响力性能,而修复这些问题会破坏现有的规则;
- 2. Eslint 的性能更好,并且社区用户通常拥有 ESLint 的配置规则(比如针对 React 和 Vue 的规则),而不会拥有 TSLint 的配置规则.
