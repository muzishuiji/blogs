# 递归

递归是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。
1. **递**：程序不断深入调用自身，通常传入更小或更简化的函数，直到达到“终止条件”；
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果；

从实现的角度看，递归代码主要包含三个要素：
1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的函数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

## 调用栈

递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这竟导致两方面的结果。
- 函数的上下文数据都存储在“栈帧空间”的内存区域中，直到函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。
- 递归调用函数会产生往外的开销，因此递归通常比循环的时间效率更低。

在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出报错。

## 尾递归

有趣的是，如果函数在返回钱的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当，这种情况被称为“尾递归”。

- **普通递归**：当函数返回上一层的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- **尾递归**：递归函数是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无需继续执行其他操作，因此系统无需保存上一层函数的上下文。

> 很多编译器或解释器并不支持尾递归优化，例如，python默认不支持尾递归优化，因此即使函数是尾递归形式，但任然可能遇到栈溢出的问题。

## 递归树

当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观，代码更加易读。

从本质上看，递归体现“将问题分解为更小子问题”的思维范式，这种分治策略时至关重要的。
- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略都直接或间接的应用这种思维方式。
- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为他们非常适合用分治思想进行分析。

## 迭代与递归的对比

|维度|迭代|递归|
|---|---|---|
|实现方式|循环结构|函数调用自身|
|时间效率|效率通常较高，无函数调用开销|每次函数调用都会产生开销|
|内存使用|通常使用固定大小的内存空间|累积函数调用可能使用大量的栈帧空间|
|适用问题|适用于简单循环任务，代码客观、可读性好|适用于子问题分析，如树、图、分治、回溯等，代码结构简洁、清晰|
